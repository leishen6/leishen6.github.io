<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AQS之ReentLock源码解析</title>
      <link href="/2020/05/24/AQS_ReentLock_source_code_analysis/"/>
      <url>/2020/05/24/AQS_ReentLock_source_code_analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java中的同步类<strong>ReentrantLock</strong>是基于AbstractQueuedSynchronizer（简称为<strong>AQS</strong>）实现的。</p><p>今天从源码来了解下<strong>ReentrantLock</strong>中非公平锁的加锁和释放锁（<strong>ReentrantLock</strong>中支持公平锁和非公平锁，默认是非公平锁的，但可以通过创建<strong>ReentrantLock</strong>对象时传入参数指定使用公平锁）。</p><p>在了解<strong>ReentrantLock</strong>前，需要对<strong>AQS</strong>有一定的了解，否则在学习时会比较困难的，并且在通过源码学习<strong>ReentrantLock</strong>时也会穿插着讲解<strong>AQS</strong>内容。</p></blockquote><h2 id="AQS扫荡："><a href="#AQS扫荡：" class="headerlink" title="AQS扫荡："></a>AQS扫荡：</h2><h4 id="1-0、AQS中state变量"><a href="#1-0、AQS中state变量" class="headerlink" title="1.0、AQS中state变量"></a>1.0、AQS中state变量</h4><p>​        AQS中提供了一个int类型的<strong>state</strong>变量，并且<strong>state</strong>变量被<strong>volatile</strong>修饰，表示<strong>state</strong>变量的<strong>读写操作</strong>可以保证原子性；并且AQS还提供了针对<strong>state</strong>变量的读写方法，以及使用CAS算法更新<strong>state</strong>变量的方法。<font size="3" color="red"> AQS使用<strong>state</strong>变量这个状态变量来实现同步状态。</font></p><p><strong>①、源码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get 获取state变量值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set 更新state变量值 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState  新的状态变量值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CAS算法更新state变量值; 当从共享内存中读取出的state变量值与expect期望值一致的话，</span></span><br><span class="line"><span class="comment"> * 就将其更新为update值。使用CAS算法保证其操作的原子性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect  期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update  更新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Unsafe类的本地方法来实现CAS</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1、state同步状态的竞争"><a href="#1-1、state同步状态的竞争" class="headerlink" title="1.1、state同步状态的竞争"></a>1.1、state同步状态的竞争</h4><p>​        多个线程同时竞争AQS的<strong>state同步状态</strong>，在同一时刻只能有一个线程获取到同步状态（获取到锁），那其它没获取到锁的线程该怎么办呢<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085104.gif" alt=""></p><blockquote><p>它们会进去到一个同步队列中，在队列中等待同步锁的释放；</p><p>这个同步队列是一个<font size="3" color="red"><strong>基于链表的双向队列</strong></font> ,  基于链表的话，就会存在<strong>Node节点</strong>，那么AQS中节点是怎么实现的呢<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085104.gif" alt=""></p></blockquote><p><strong>①、Node节点：</strong></p><p>AQS中自己实现了一个内部Node节点类，Node节点类中定义了一些属性，下面来简单说说属性的意思：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标志在同步队列中Node节点的模式，共享模式 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// 标志在同步队列中Node节点的模式，独占（排他）模式 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitStatus值为1时表示该线程节点已释放（超时等），已取消的节点不会再阻塞。 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// waitStatus值为-1时表示当此节点的前驱结点释放锁时，然后当前节点中的线程就可以去获取锁运行 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus为-2时，表示该线程在condition队列中阻塞（Condition有使用），</span></span><br><span class="line"><span class="comment">         * 当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从</span></span><br><span class="line"><span class="comment">         * 等待队列转移到同步队列中，等待获取同步锁。</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus为-3时，与共享模式有关，在共享模式下，该状态表示可运行</span></span><br><span class="line"><span class="comment">         * （CountDownLatch中有使用）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus：等待状态，指的是当前Node节点中存放的线程的等待状态，</span></span><br><span class="line"><span class="comment">         * 等待状态值就是上面的四个状态值：CANCELLED、SIGNAL、CONDITION、PROPAGATE</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为同步队列是双向队列，那么每个节点都会有指向前一个节点的 prev 指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为同步队列是双向队列，那么每个节点也都会有指向后一个节点的 next 指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Node节点中存放的阻塞的线程引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前节点与其next后继结点的所属模式，是SHARED共享模式，还是EXCLUSIVE独占模式，</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 注：比如说当前节点A是共享的，那么它的这个字段是shared，也就是说在这个等待队列中，</span></span><br><span class="line"><span class="comment">         * A节点的后继节点也是shared。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前节点是否为共享模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前节点的 prev前驱结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在后面的addWaiter方法会使用到，线程竞争state同步锁失败时，会创建Node节点存放thread</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     </span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>②、同步队列结构图（双向队列）：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524090454.png" alt=""></p><h4 id="1-2、图解AQS原理"><a href="#1-2、图解AQS原理" class="headerlink" title="1.2、图解AQS原理"></a>1.2、图解AQS原理</h4><p>​       通过前面两点，可以了解到AQS的原理到底是什么了，总结为一句话：<font size="3" color="red">AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</font></p><p> 然后再来一张图，使得理解更加深刻：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524160423.png" alt=""></p><p> 图片来源： <a href="https://www.jianshu.com/p/da9d051dcc3d" target="_blank" rel="noopener">Java技术之AQS详解</a></p><blockquote><p>好了，<strong>AQS</strong>暂时可以先了解到这里了，知道这些后，在后面了解<strong>ReentrantLock</strong>时就会变的容易些，并且后面通过源码学习<strong>ReentrantLock</strong>时，由于会使用到AQS的模版方法，所以也会讲解到AQS的内容。</p></blockquote><h2 id="剑指ReentrantLock源码："><a href="#剑指ReentrantLock源码：" class="headerlink" title="剑指ReentrantLock源码："></a>剑指<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524094904.gif" alt="">ReentrantLock源码：</h2><h4 id="2-0、ReentrantLock-vs-Synchronized"><a href="#2-0、ReentrantLock-vs-Synchronized" class="headerlink" title="2.0、ReentrantLock  vs  Synchronized"></a>2.0、ReentrantLock <font size="6" color="red"> vs </font> Synchronized</h4><p>​       在了解<strong>ReentrantLock</strong>之前，先将<strong>ReentrantLock</strong>与<strong>Synchronized</strong>进行比较下，这样可以更加了解<strong>ReentrantLock</strong>的特性，也有助于下面源码的阅读；</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524122513.png" alt=""></p><h4 id="2-1、ReentrantLock的公平锁与非公平锁"><a href="#2-1、ReentrantLock的公平锁与非公平锁" class="headerlink" title="2.1、ReentrantLock的公平锁与非公平锁"></a>2.1、ReentrantLock的公平锁与非公平锁</h4><p>创建一个<strong>ReentrantLock</strong>对象，在创建对象时，如果不指定公平锁的话，默认是非公平锁；</p><p><strong>①、简单了解下什么是公平锁，什么是非公平锁？</strong></p><blockquote><p>公平锁：按照申请同步锁的顺序来获取锁；</p><p>非公平锁：不会按照申请锁的顺序获取锁，存在锁的抢占；</p><p><font size="3" color="red">注：后面会通过源码了解下非公平锁和公平锁是怎样获取锁的。</font></p></blockquote><p><strong>②、源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是非公平的锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 构造方法默认创建了一个 NonfairSync 非公平锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NonfairSync继承了Sync类，Sync类又继承了AQS类</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入参数 true，指定为公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 传入参数的构造方法，当fair为true时，创建一个公平锁对象，否则创建一个非公平锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、通过源码看下非公平锁的加锁机制：（独占模式）"><a href="#2-2、通过源码看下非公平锁的加锁机制：（独占模式）" class="headerlink" title="2.2、通过源码看下非公平锁的加锁机制：（独占模式）"></a>2.2、通过源码看下<strong>非公平锁</strong>的加锁机制：（独占模式）</h4><p>①、开始先通过一个简单流程图来看下独占模式下加锁的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524152416.png" alt=""></p><p>​          图片来源：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">美团技术团队</a></p><p>②、源码分析：加锁时首先使用CAS算法尝试将state状态变量设置为1，设置成功后，表示当前线程获取到了锁，然后将独占锁的拥有者设置为当前线程；如果CAS设置不成功，则进入Acquire方法进行后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用CAS算法尝试将state状态变量设置为1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置成功后，表示当前线程获取到了锁，然后将独占锁的拥有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 进行后续处理，会涉及到重入性、创建Node节点加入到队列尾等</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、探究下<strong>acquire(1)</strong> 方法里面是什么呢<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085104.gif" alt="">   acquire(1) 方法是AQS提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用tryAcquire()方法，让当前线程尝试获取同步锁，获取成的话，就不会执行后面的acquireQueued()</span></span><br><span class="line"><span class="comment">     * 方法了，这是由于 &amp;&amp; 逻辑运算符的特性决定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果使用tryAcquire()方法获取同步锁失败的话，就会继续执行acquireQueued（）方法，它的作用是</span></span><br><span class="line"><span class="comment">     * 一直死循环遍历同步队列，直到使addWaiter()方法创建的节点中线程获取到锁。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果acquireQueued()返回的true，这个true不是代表成功的获取到锁，而是代表当前线程是否存在</span></span><br><span class="line"><span class="comment">     * 中断标志，如果存在的话，在获取到同步锁后，需要使用selfInterrupt()对当前线程进行中断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）</strong>、<strong>tryAcquire(arg)</strong> 方法源码解读：NonfairSync 非公平锁中重写了AQS的tryAcquire()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前state同步状态变量值，由于使用volatile修饰，单独的读写操作具有原子性</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果状态值为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用compareAndSetState方法这个CAS算法尝试将state同步状态变量设置为1 获取同步锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 然后将独占锁的拥有者设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果拥有独占锁的的线程是当前线程的话,表示当前线程需要重复获取锁（重入锁）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前同步状态state变量值加1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 写入state同步状态变量值，由于使用volatile修饰，单独的读写操作具有原子性</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）</strong>、<strong>addWaiter( Node.EXCLUSIVE )</strong> ：创建一个同步队列Node节点，同时绑定节点的模式为独占模式，并且将创建的节点插入到同步队列尾部；addWaiter( ) 方法是AQS提供方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// model参数是独占模式，默认为null；</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将当前同步队列的tail尾节点的地址引用赋值给pre变量</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果pre不为null，说明同步队列中存在节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点的前驱结点指向pre尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS算法将当前节点设置为尾节点，使用CAS保证其原子性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 尾节点设置成功，将pre旧尾节点的后继结点指向新尾节点node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果尾节点为null，表示同步队列中还没有节点，enq（）方法将当前node节点插入到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）</strong>、说完addWaiter( Node.EXCLUSIVE )方法，接下来说下<strong>acquireQueued（）</strong>方法，它是怎样使addWaiter()创建的节点中的线程获取到state同步锁的。（这个方法也是AQS提供的）  <img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085622.gif" alt="">    </p><p><strong>源码走起：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标志cancelAcquire()方法是否执行</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标志是否中断，默认为false不中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果当前节点的前驱结点已经是同步队列的头结点了，说明了两点内容：</span></span><br><span class="line"><span class="comment">             * 1、其前驱结点已经获取到了同步锁了,并且锁还没释放</span></span><br><span class="line"><span class="comment">             * 2、其前驱结点已经获取到了同步锁了，但是锁已经释放了</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 然后使用tryAcquire()方法去尝试获取同步锁，如果前驱结点已经释放了锁，那么就会获取成功，</span></span><br><span class="line"><span class="comment">             * 否则同步锁获取失败，继续循环</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为同步队列的head头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 然后将当前节点的前驱结点的后继结点置为null，帮助进行垃圾回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断的标志</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * shouldParkAfterFailedAcquire()是对当前节点的前驱结点的状态进行判断，以及去针对各种</span></span><br><span class="line"><span class="comment">             * 状态做出相应处理，由于文章篇幅问题，具体源码本文不做讲解；只需知道如果前驱结点p的状态为</span></span><br><span class="line"><span class="comment">             * SIGNAL的话，就返回true。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * parkAndCheckInterrupt()方法会使当前线程进去waiting状态，并且查看当前线程是否被中断，</span></span><br><span class="line"><span class="comment">             * interrupted() 同时会将中断标志清除。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 中断标志置为true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果for(;;)循环中出现异常，并且failed=false没有执行的话,cancelAcquire方法</span></span><br><span class="line"><span class="comment">             * 就会将当前线程的状态置为 node.CANCELLED 已取消状态，并且将当前节点node移出</span></span><br><span class="line"><span class="comment">             * 同步队列。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）</strong>、最后说下 <strong>selfInterrupt()</strong> 方法， 这个方法就是将当前线程进行中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中断当前线程</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、公平锁与非公平锁在加锁时的区别："><a href="#2-3、公平锁与非公平锁在加锁时的区别：" class="headerlink" title="2.3、公平锁与非公平锁在加锁时的区别："></a>2.3、公平锁与非公平锁在加锁时的区别：</h4><p>①、公平锁 <strong>FairSync</strong> 的加锁 <strong>lock()</strong> 加锁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、非公平锁 <strong>NonfairSync</strong> 的加锁 <strong>lock()</strong> 加锁方法：上面讲解源码的时候有提到哟，还有印象吗，没印象的话也没关系，不要哭<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085618.gif" alt="">  ，  嘿嘿，我都准备好了<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085118.gif" alt="">。  源码奉上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 看到这，是不是发现了什么，非公平锁在此处直观看的话，发现比公平锁多了这几行代码; </span></span><br><span class="line"><span class="comment">     * 这里就是使得线程存在了一个抢占，如果当前同步队列中的head头结点中 线程A 刚好释放了同步锁，</span></span><br><span class="line"><span class="comment">     * 然后此时 线程B 正好来了，那么此时线程B就会获取到锁，而此时同步队列中head头结点的后继结点中的</span></span><br><span class="line"><span class="comment">     * 线程C 就无法获取到同步锁，只能等待线程B释放锁后，尝试获取锁了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、除了上面那处不同之外，还有别的地方吗；别急，再看看 <strong>acquire(1)</strong>  方法是否一样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        诶呀，方法点进去都是一样的呀，可不嘛，都是调用的AQS提供的 <strong>acquire(1)</strong>  方法；但是别着急，上面在讲解非公平锁加锁时，有提到的 <strong>tryAcquire(arg)</strong> 方法在AQS的不同子孙类中都有各自的实现的。现在打开公平锁的 <strong>tryAcquire(arg)</strong>  方法看看其源码与非公平锁有什么区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过对比源码发现，公平锁比非公平锁多了这块代码： !hasQueuedPredecessors() </span></span><br><span class="line"><span class="comment">         * hasQueuedPredecessors() 是做什么呢？就是判断当前同步队列中是否存在节点，如果存在节点呢，</span></span><br><span class="line"><span class="comment">         * 就返回true，由于前面有个 ！，那么就是false，再根据 &amp;&amp; 逻辑运算符的特性，不会继续执行了;</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * tryAcquire()方法直接返回false，后面的逻辑就和非公平锁的一致了，就是创建Node节点，并将</span></span><br><span class="line"><span class="comment">         * 节点加入到同步队列尾; 公平锁：发现当前同步队列中存在节点，有线程在自己前面已经申请可锁，那</span></span><br><span class="line"><span class="comment">         * 自己就得乖乖的向后面排队去。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 友情提示：在生活中，我们也需要按照先来后到去排队，保证素质; 还有就是怕你们不排队被别人打了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>松口气，从中午一直写到下午快四点了，先让我歇口气，快累成狗了；本文还剩下释放锁部分没写呢，歇口气，喝口水继续<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085639.gif" alt="">。</p><p><font size="3" color="red">注意：ReentrantLock在释放锁的时候，并不区分<strong>公平锁和非公平锁</strong>。</font></p></blockquote><h4 id="2-4、通过源码看下释放锁机制：（独占模式）"><a href="#2-4、通过源码看下释放锁机制：（独占模式）" class="headerlink" title="2.4、通过源码看下释放锁机制：（独占模式）"></a>2.4、通过源码看下释放锁机制：（独占模式）</h4><p>①、<strong>unlock()</strong>  释放锁的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁时，需要将state同步状态变量值进行减 1，传入参数 1</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、<strong>release( int arg )</strong> 方法解析：（此方法是AQS提供的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryRelease方法：尝试释放锁，成功true，失败false</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况,然后唤醒此阻塞的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3" color="red">注意：这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</font></p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p><p>h != null &amp;&amp; waitStatus == 0  表明后继节点对应的线程仍在运行中，不需要唤醒。</p><p>h != null &amp;&amp; waitStatus  &lt;  0  表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>③、然后再来看看<strong>tryRelease(arg)</strong>  方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前state状态值进行减一</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前独占锁的拥有者不是当前线程，则抛出 非法监视器状态 异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新state同步状态值</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、最后看看<strong>unparkSuccessor(Node node)</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点waitStatus</span></span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">Node s = node.next;</span><br><span class="line"><span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled状态的节点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line"><span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点的后继结点不为null，则将其节点中处于阻塞状态的线程unpark唤醒</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3" color="red">注意：为什么要从后往前找第一个非Cancelled的节点呢？原因如下:</font></p><p>由于之前加锁时的addWaiter( )方法的原因；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// model参数是独占模式，默认为null；</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将当前同步队列的tail尾节点的地址引用赋值给pre变量</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果pre不为null，说明同步队列中存在节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点的前驱结点指向pre尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS算法将当前节点设置为尾节点，使用CAS保证其原子性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 尾节点设置成功，将pre旧尾节点的后继结点指向新尾节点node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果尾节点为null，表示同步队列中还没有节点，enq（）方法将当前node节点插入到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，节点入队并不是原子操作，也就是说，<font size="3" color="blue">node.prev = pred ;   compareAndSetTail( pred, node ) </font>这两个地方可以看作Tail入队的原子操作，但是此时  <font size="3" color="red">pred.next =  node; </font> 还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，<font size="3" color="red">在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开</font>，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><blockquote><p>end！ 长吸一口气，终于本文算是写完了，最后再看看有没有错别字，以及排排版。</p><p>后续还会出一篇结合<strong>CountDownLatch</strong>源码学习共享锁（共享模式）的文章。</p></blockquote><table><tbody><tr><td bgcolor="#FF00FF"><font size="5" color="#fffff">谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></tbody></table><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">1、从ReentrantLock的实现看AQS的原理及应用</a><br><a href="https://www.jianshu.com/p/da9d051dcc3d" target="_blank" rel="noopener">2、Java技术之AQS详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS队列同步器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟实战排查堆内存溢出（java.lang.OutOfMemoryError Java heap space）问题</title>
      <link href="/2020/05/15/simulation_heap_OutOfMemory_screening/"/>
      <url>/2020/05/15/simulation_heap_OutOfMemory_screening/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>模拟实战中排查堆内存溢出（<font color="red"><strong>java.lang.OutOfMemoryError: Java heap space</strong></font >）的问题。<br>堆内存溢出的原因：一般都是创建了大量的对象，这些对象一直被引用着，无法被GC垃圾回收掉，最终导致堆内存被占满，没有足够的空间存放新创建的对象时，就会出现堆内存溢出问题。<br>在实际的业务场景中出现内存溢出的问题，排查起来一般是十分困难繁琐的，本文将通过结合一个简单的实例来阐述排查的具体思路和步骤。</p></blockquote><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><blockquote><p>注意：<font color="red">在实际场景中，一般都是部署在Linux服务器中的项目报出内存溢出的问题；为了尽可能还原出实际场景，本文也是将提前编写好的可以触发内存溢出的代码并打包成可运行的Jar包，然后放到服务器中执行的。</font></p></blockquote><p><strong>1、准备可导致内存溢出的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfMemory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutOfMemory</span><span class="params">(String test)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test = test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟内存溢出的发生</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;OutOfMemory&gt; list = <span class="keyword">new</span> ArrayList&lt;OutOfMemory&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 无限创建OutOfMemory对象，直至将堆空间占满，并且创建的OutOfMemory对象一直被list集合对象引用着，</span></span><br><span class="line"><span class="comment">         * 导致GC也无法回收，最终出现堆内存溢出问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="keyword">new</span> OutOfMemory(<span class="string">"5656"</span>));</span><br><span class="line">        System.out.println(<span class="string">"5656"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><tbody><tr><td bgcolor="#FF00FF"><font size="4" color="#fffff">代码编写完成后，使用开发工具导出<B>可运行的Jar包</B>— （TestOOM.jar）</font></td></tr></tbody></table><br><p><strong>2、准备Linux服务器</strong></p><blockquote><p>可以直接使用centos或者Red Hat等都可以；</p></blockquote><h2 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h2><p><strong>1、将可运行的Jar包放到服务器中执行：</strong><br>①、可使用xshell、xftp工具将可运行的Jar包（Jar包叫：<font color="red"><strong>TestOOM.jar</strong></font>）放入到服务器中；<br>②、使用命令执行Jar包；命令：<br>       &nbsp;&nbsp; &nbsp; java <font color="red"> -Xms40m -Xmx70m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/tmp</font> -jar TestOOM.jar</p><p>  &nbsp;&nbsp; &nbsp; 注意：为了尽快模拟发生堆内存溢出，所以在启动Jar包时，设置了一些参数；参数解析：<br>  &nbsp;&nbsp; &nbsp; 1）、 -Xms40m   初始堆大小设置为40m<br>  &nbsp;&nbsp; &nbsp; 2）、 -Xmx70m   最大堆大小设置为70m<br>  &nbsp;&nbsp; &nbsp; 3）、 -XX:+HeapDumpOnOutOfMemoryError   出现堆内存溢出时，自动导出堆内存 dump 快照<br>  &nbsp;&nbsp; &nbsp; 4）、 -XX:HeapDumpPath=/usr/tmp   设置导出的堆内存快照的存放地址为 /usr/tmp</p><p><strong>2、执行成功后，使用JVM监控命令监控JVM的信息：</strong><br>①、jps命令：此命令是用来查询与Java相关的进程的，并输出进程号；下图就是展示上面运行的Jar包的进程号：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTMxMC5wbmc?x-oss-process=image/format,png" alt=""><br>②、jmap命令：<font color="red"> jmap -heap 3324 </font>    &nbsp;此命令是查询出进程号为 3324 的JVM中堆内存信息；如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTMyMy5wbmc?x-oss-process=image/format,png" alt=""></p><blockquote><p>在图中可以发现堆内存中新生代、年老代中 free 可用空间越来越小，这预示着即将会发生GC垃圾回收，从而使堆腾出更多的空间存放新创建的对象。</p></blockquote><p>③、jstat命令：使用其监控JVM的性能信息；例如：在本次排查内存溢出的问题中，会使用 jstat 命令监控 JVM的 GC垃圾回收的情况；<br>&nbsp;&nbsp; 命令：<font color="red"> jstat -gcutil 3324 1000 </font>  &nbsp;  意思是每1000毫秒查询一次进程号为3324 的JVM的GC垃圾回收的情况；如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTMxOC5wbmc?x-oss-process=image/format,png" alt=""></p><blockquote><p>（1）、 YGC(堆中新生代GC)、FGC( FULL GC)为什么触发频率这么快呢？<br>答：由于堆内存空间不够用了，需要通过GC垃圾回收将一些空间进行回收，用于存放新创建的对象。</p></blockquote><blockquote><p>（ 2）、当堆内存空间不够用时，GC具体会发生什么呢？<br>答：<br>1）、当堆中的新生代空间不够用时，会触发YGC，对堆中新生代空间进行垃圾回收，同时垃圾回收后剩余存活的对象会移动到堆中<br>老年代存储，所以每次YGC后，堆中年老代中存储的对象数量会增大；<br>2）、当堆的新生代即将发生YGC时，如果发现新生代中存活下来的对象比堆中年老代中剩余的刻意空间大的话，就会直接不进行YGC，<br>而会直接触发FGC，FULL GC会对整个堆空间（新生代、老年代）以及方法区/永久代进行垃圾回收；</p></blockquote><table><tbody><tr><td bgcolor="#FF00FF"><font size="4" color="#fffff">扩展：堆的结构图</font></td></tr></tbody></table><div align=center><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTQwNS5wbmc?x-oss-process=image/format,png" alt=""></div></p><p><strong>3、出现内存溢出后，会自动生成快照，然后分析堆内存快照：</strong></p><p>①、使用XFTP等工具将服务器中的快照文件导出，堆内存快照文件是以<font color="red"> hprof </font>为后缀的文件；导出快照文件后，可以通过JDK自带的<font color="red">  jvisualvm.exe  </font>分析工具打开进行分析。</p><blockquote><p>jvisualvm.exe 是在哪里呢？（以 windows 系统为例）<br>它是在<font color="red">JDK的安装目录中的bin目录下的</font>。</p></blockquote><p>如图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTM1NC5wbmc?x-oss-process=image/format,png" alt=""><br>②、使用 jvisualvm.exe 导入快照文件，如图：<br>（1）、<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTE0NDMwMi5wbmc?x-oss-process=image/format,png" alt=""><br>（2）、<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTE0NDMxNi5wbmc?x-oss-process=image/format,png" alt=""><br>（3）、<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTE0NDMzNS5wbmc?x-oss-process=image/format,png" alt="">     </p><blockquote><p>通过分析堆内存快照得到的结论：<br>通过第（3）张图，可以发现堆内存中有一个实例对象的占比为 99.9%，可以确定是由于这个实例对象大量创建导致堆内存的溢出；<br>说到这，可以回过头去看下我们自己编写的可以触发堆内存溢出的小程序，发现正是由于在 <font color="red"> while(true) </font>死循环 中无线创建 OutOfMemory对象，导致堆内存空间被耗尽。</p></blockquote><blockquote><p><b><font color="blue"> 结语：</font></b><br>通过上面的实战小例子，我们可以大体了解到在出现堆内存溢出时的排查步骤，但是在实际的场景中，这种情况可能会更加的复杂多变；<br>比如说，上面的那个小例子在出现的堆内存溢出时自动生成的堆内存快照文件大小就达到了100多m，如果在实际的场景中，这个可能是非常巨大的，这时可能就会发生快照分析工具无法导入堆内存快照。所以说，我们需要在平时通过不断的学习，才能在未来出现问题时，能尽快定位问题并解决问题；程序员不光是能编写好代码，还需要有解决问题的能力。</p></blockquote><br><table><tr><td bgcolor=#FF00FF><font size = 4px>谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 实战问题排查 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Java实现简单的监控系统</title>
      <link href="/2020/05/05/Java_impl_monitor_system/"/>
      <url>/2020/05/05/Java_impl_monitor_system/</url>
      
        <content type="html"><![CDATA[<p><br><table><tbody><tr><td bgcolor="#FF00FF"><font size="5" color="#fffff">本文只是简单介绍了下监控系统实现的思路，具体还需根据自己需求实现。</font></td></tr></tbody></table><br></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>目前存在一个后台服务系统，此时需要配套一个监控系统，对这个后台服务系统进行监控。下面会涉及到两个系统，后台服务系统（这是已经存在的系统），监控系统（此次需要进行开发的系统）。<font color=red>注意：后面统一将后台服务系统称作服务系统</font>。</p></blockquote><h2 id="具体需求："><a href="#具体需求：" class="headerlink" title="具体需求："></a>具体需求：</h2><p>1、监控服务系统的运行状态，服务系统是否存活，采用模拟数据进行访问接口，如果已down则需要发送告警邮件；</p><p>2、监控服务系统的所有接口是否正常运行，采用模拟数据进行访问接口，如果有问题需要发送告警邮件，邮件内容是模拟访问接口返回的响应；（注：后台服务系统中自定义了相关响应状态码和对应的响应描述）</p><p>3、监控部署了服务系统的服务器的磁盘、CPU、内存的使用情况，会提前设置好使用阀值，如果超过阀值，则要发送告警邮件；</p><p>4、数据采集功能：采集每日服务系统的总访问量、日最大并发量，记录入库，后期做图表展示；</p><p>5、除了上面几个需求外，监控系统还需要具备一些配置页面，用来配置一些监控系统使用的参数：<br>   ①、添加报警邮件配置参数页面，用于配置报警邮件的发送人、收件人等参数；<br>   ②、添加服务器使用阀值的配置参数页面，页面中可以设置服务器（部署后台服务系统的服务器）的磁盘、CPU、内存使用阀值，超过 阀值时需要进行报警；<br>   ③、添加服务器配置页面，这些服务器就是部署了服务系统的机器，它们的ip地址及端口号参数；</p>   <br><blockquote><p>注意：知道了大概的需求后，还要结合服务系统的实际部署方案进行构思具体的开发；<br>   前提：服务系统的部署是以集群（集群：就是将后台服务系统部署在多态服务器中，然后使用Nginx或F5进行请求的转发和负载均衡）的形式进行部署的。</p></blockquote><h2 id="开发构思："><a href="#开发构思：" class="headerlink" title="开发构思："></a>开发构思：</h2><table><tbody><tr><td bgcolor="#03FEED"><font size="5" color="#fffff">定时任务、报警邮件发送所使用工具：</font></td></tr></tbody></table>1、监控系统首先需要实时监控的，所以说会需要定时任务，定时任务使用Quartz来实现。<p>2、发送告警邮件可以使用Hutool这个工具包中的邮件工具类来实现，非常简单方便。</p><table><tbody><tr><td bgcolor="#03FEED"><font size="5" color="#fffff">在服务系统中添加一个filter请求过滤器，这个过滤器主要作用：</font></td></tr></tbody></table>3、服务系统改造：<br>   ①、统计服务系统日总访问量，将每日的日总访问量数据放到redis中，redis存储的key为：当前服务器ip地址+当前日期；每当来一个 请求，就将redis中存储的数据加一；<p>   ②、统计实时的日最大并发访问量也是在该过滤器中，并且将最大并发访问量也是存在redis中，key为：当前服务器ip地址+ “max” + 当前日期；服务系统每来一个请求，就将redis中存储的数据加一，请求处理完成就将redis中存储的数据再减一；</p><table><tbody><tr><td bgcolor="#03FEED"><font size="5" color="#fffff">监控系统中的定时任务：</font></td></tr></tbody></table><p>4、监控系统中的定时任务：<br>   ①、<a href="https://blog.csdn.net/feichitianxia/article/details/104056510" target="_blank" rel="noopener">获取服务器的cpu、内存、磁盘使用情况可以使用shell脚本获取</a>，然后Java操作shell脚本执行并获取到当前服务器的磁盘、CPU、内存的使用率，然后与配置页面中提前配置的使用阀值进行比较，大于阀值的话就需要发送报警邮件。（定时任务，每隔30分钟执行一次）</p><p>   ②、使用定时任务监控后台服务系统是否存活，以及监控所有接口是否正常，根据响应状态码判断出现问题进行报警邮件发送。（定时任务，每隔5分钟执行一次）</p><p>   ③、使用定时任务统计每日最大并发访问量，因为服务系统过滤器中已经统计了服务系统集群中每个节点实时的日最大访问量并存在了redis中，而此时需要一个定时任务将集群的总日最大访问量进行汇总，并存入redis中，此时key为：”max”+当前日期，后面定时任务在每次执行时，都需要先将集群的总日最大并发访问量进行汇总后，与上次 定时任务的统计的日最大并发访问量进行对比，如果比上次统计的大，则将redis中存储的集群总日最大并发访问量更新为当前的；这时操作redis需要至少两步，先读取，然后判断大小，如果大还会去更新，<font color=red>为了保证操作的原子性，需要使用Lua脚本</font>；（定时任务，每隔5秒执行一次，即使这样的话，统计的最大访问量也可能不是准确的，但是也可作为参考）</p><p><font color=red>   <strong>Lua脚本伪代码：</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* lua 脚本：</span></span><br><span class="line"><span class="comment"> * 1、判断key是否存在，key不存在，则新增key-value，value默认为0；</span></span><br><span class="line"><span class="comment"> * 2、如果key存在，则取出value，然后与输入参数进行比较，输入参数大的话就将key的value值更新为输入参数值，否则不进行任何操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String luaScript = <span class="string">"local flag = redis.call('exists',KEYS[1])\n"</span></span><br><span class="line">        + <span class="string">"if (flag == 0) then\n"</span></span><br><span class="line">        +     <span class="string">"redis.call('set', KEYS[1], 1)\n"</span></span><br><span class="line">        + <span class="string">"else \n"</span></span><br><span class="line">        +     <span class="string">"if tonumber(redis.call('get', KEYS[1])) &lt; tonumber(ARGV[1]) then\n"</span></span><br><span class="line">        +         <span class="string">"redis.call('set', KEYS[1], ARGV[1])\n"</span></span><br><span class="line">        +     <span class="string">"end\n"</span></span><br><span class="line">        + <span class="string">"end"</span>;</span><br></pre></td></tr></table></figure><p>   ④、使用定时任务将每台服务器在redis中对应的每日总访问量取出汇总，存入数据库中，以及日最大并发访问量入库。（定时任务，每天的凌晨一分时执行，是统计前一天的总访问量）</p><h2 id="开发构思解析："><a href="#开发构思解析：" class="headerlink" title="开发构思解析："></a>开发构思解析：</h2><p>1、为什么使用redis存放总访问量以及最大访问量呢？因为服务系统是以集群的形式部署的，所以需要统计集群中所有节点的访问量，将其存入redis这种第三方的地方是比较方便的，注意，存在redis中的这些访问量数据需要设置过期时间的，否则redis中数据会导致越来越多，占用内存；</p><p>2、由于使用到了shell脚本获取服务器的磁盘、CPU、内存的使用率，那么集群中的每台服务器都需要存放、运行提前写好的shell脚本，那么也是需要在集群中每台服务器中也要部署    监控系统的；监控系统在部署了集群后，为了保证同一时刻只有一台监控系统运行着定时任务，所以在每个定时任务运行前先设置分布式锁，使用redis设置，设置分布式锁失败的话，就说明集群中有监控系统在执行了，防止定时任务重复执行以及重复数据统计。</p><p>3、在监控系统中配置页面配置的各种参数，是存入在数据库中，集群中所以监控系统连接同一个数据库，当在系统启动时使用监听器从数据库中加载进来的；那么当如果在运行阶段更新了配置参数怎么办呢，因为监控系统是部署的集群，怎么提醒集群中的监控系统去数据库中重新加载新配置数据呢？还是使用redis，key随便，value为时间戳，当集群中的所有监控系统在初始加载配置参数时，会在各自本地设置一个时间戳，redis中也设置了相同的时间戳，当在配置页面修改配置参数时，需要更新时间戳，那么监控系统在使用配置参数时，会对比一个redis中存储的时间戳和本地的时间戳是否一致，不一致说明配置参数更新了，需要到数据库重新加载读取参数。</p><h2 id="开发中遇到的问题："><a href="#开发中遇到的问题：" class="headerlink" title="开发中遇到的问题："></a>开发中遇到的问题：</h2><p>1、<a href="https://blog.csdn.net/feichitianxia/article/details/104071943" target="_blank" rel="noopener">使用Hutool这个工具包中的邮件工具类发送报警邮件出现了一个小问题</a>，邮件配置参数重新去数据库中读取加载了，但是这个工具类使用到的参数还是原来的旧参数，这里是由于工具类中的默认使用的是全局session，所以导致新配置参数不生效；</p><p>2、在多台服务器进行部署服务系统时，监控系统也跟随进行部署多台，那么在数据采集的定时任务由于设置了redis分布式锁，所以不会导致定时任务重复进行采集；但是由于多台服务器的系统时间不一致导致了在每台服务器上部署的监控系统的定时任务会重复执行，就会导致数据库中日最大并发访问量、日总访问量的重复数据产生。即使使用了分布式锁也没有用了。所以在定时任务统计数据入库操作前需要加上校验，校验是否已经存在了这条数据即可。</p><br><table><tbody><tr><td bgcolor="#FF00FF"><font size="5" color="#fffff">谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工作所遇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊Java中的锁，这也是面试时不可避免的 &quot; 锁 &quot; 事！</title>
      <link href="/2020/05/03/chat_java_lock_things/"/>
      <url>/2020/05/03/chat_java_lock_things/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。</p></blockquote><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUwMzE2MjEwNS5wbmc?x-oss-process=image/format,png" alt=""></p><table><tbody><tr><td bgcolor="#FFA500"><font size="5" color="#fffff">这些只是简单的概念，具体可以根据源码学习！</font></td></tr></tbody></table><br><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect" target="_blank" rel="noopener"> 美团技术团队 ：【基本功】不可不说的Java“锁”事 </a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典面试题（一）、静态代码块、静态属性、构造方法的执行顺序</title>
      <link href="/2020/04/16/written_test_topic_static_construction_run_squence/"/>
      <url>/2020/04/16/written_test_topic_static_construction_run_squence/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>在面试时，下面这道题应该经常遇到；那大家看看这道题中运行Test4中main方法后，控制台的输出内容的顺序是什么样的呀？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3 static start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3 gouzao start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Test4的静态属性类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test5 static start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test5 gouazao start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> <span class="keyword">extends</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Test5 t5 = <span class="keyword">new</span> Test5();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test4 static start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">"test4 gouzao start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test4 t4 = <span class="keyword">new</span> Test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那我们运行上面子类Test4中的main方法，看看输出内容的顺序是怎样的？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main方法运行结果</span></span><br><span class="line"></span><br><span class="line">test3 <span class="keyword">static</span> start;</span><br><span class="line">test5 <span class="keyword">static</span> start;</span><br><span class="line">test5 gouazao start;</span><br><span class="line">test4 <span class="keyword">static</span> start;</span><br><span class="line">test3 gouzao start;</span><br><span class="line">test4 gouzao start;</span><br></pre></td></tr></table></figure><blockquote><p>大家得出的输出结果与上面的结果一样吗；不一样的话，也别桑心呀，我来带大家去一步步的解析这道题，让大家在面试的时候不在这道题上跌倒。</p></blockquote><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><table><tr><td bgcolor=##03FEED><font size = 3px>首先，大家需要知道几个知识点：</font></td></tr></table><font size = 2px>1、static 代码块的执行、static 属性的初始化都是在类加载的时候进行的；<br><br><p>2、<font size = 2px>在 new 对象时，需要先进行类加载，如果当前类有父类的话，先进行父类的类加载，再进行当前类的类加载。</font></p><p>３、<font size = 2px>类中的静态代码框的执行、静态属性初始化的执行是根据在类中书写的顺序来的；例如：<strong>Test4中的 t5 静态属性就是比静态代码框先执行的。</strong>  </font></p><p>４、<font size = 2px>在 new 对象时，在类加载完后，就该执行构造方法了，如果当前类有父类的话，就需要先执行父类的构造方法。在这里，你需要知道一个在构造方法中使用到 <strong>super();</strong> 方法，它就是进行父类构造方法的调用执行的，但是在无参构造方法中无需自己手动显示调用，JVM会在编译时将其加入进去；</font></p><br><table><tr><td bgcolor=##03FEED><font size = 3px>根据上面的知识点，解析上面的面试题</font></td></tr></table><font size = 2px>1、在 Test4 中执行 main 方法时，首先需要进行 Test4 的类加载；<br><br>2、但是由于 Test4 有父类 Test3 ，所以先进行 Test3 的类加载；<br><br>3、在执行 Test3 的类加载时，会执行静态代码框，输出 <b><font color=red>①" test3 static start; "</font></b><br><br>4、进行完父类的类加载后，执行自己 Test4 的类加载，在进行类加载时，首先执行静态属性 t5 的初始化；<br><br>5、进行 t5 初始化时，是进行的 new 对象，所以需要进行 Test5 的类加载，在进行类加载时，执行静态代码框，输出 <b><font color=red>②" test5 static start; "；</font></b><br><br>6、进行完 Test5 的类加载后，就是执行 Test5 的构造方法来完成 t5 静态属性的初始化，输出 <b><font color=red>③" test5 gouazao start; " ；</font></b><br><br>7、t5 静态属性初始化完成后，需要执行静态代码框，输出 <b><font color=red>④"test4 static start;" ；</font></b><br><br>8、此时 Test4 的类加载完成，此时需要执行构造方法创建对象，但是在执行 Test4 的构造方法时，内部会被JVM内置  super();，它会先去调用父类的构造方法执行，所以会现输出<b><font color=red> ⑤" test3 gouzao start; " </font></b>；最后才输出<b><font color=red> ⑥" test4 gouzao start; "</font></b>；</font><br><br><table><tr><td bgcolor=#FF00FF><font size = 3px>谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用滑动窗口算法查找字符串中不包含重复字符的最长子串</title>
      <link href="/2020/03/26/find_max_children_string/"/>
      <url>/2020/03/26/find_max_children_string/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>使用滑动窗口算法查找字符串中不包含重复字符的最长子串。</p></blockquote><h2 id="代码奉上："><a href="#代码奉上：" class="headerlink" title="代码奉上："></a>代码奉上：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个测试用的字符串</span></span><br><span class="line">String str = <span class="string">"asdfgrsefkkclgtdxdwee"</span>;</span><br><span class="line"> </span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n = str.length();</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (!set.contains(str.charAt(j))) &#123;</span><br><span class="line"><span class="keyword">char</span> ss = str.charAt(j++);</span><br><span class="line">set.add(ss);</span><br><span class="line">sb.append(ss);</span><br><span class="line">max = max &gt; j - i ? max : j - i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">map.put(sb.length(), sb.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(sb.length(), sb.toString());</span><br><span class="line">set.remove(str.charAt(i++));</span><br><span class="line">sb.delete(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"最大子串的长度："</span> + max);</span><br><span class="line">System.out.println(<span class="string">"最大子串："</span> + map.get(max));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java实现LRU缓存算法</title>
      <link href="/2020/03/20/Java_impl_LRU/"/>
      <url>/2020/03/20/Java_impl_LRU/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>什么是LRU算法：LRU是Least Recently Used的缩写，即最近最久未使用，是一种操作系统中常用的页面置换算法。</p></blockquote><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>知道了什么是LRU后，我们再来聊下它的使用场景；在工作中，对于Redis我们一定是比较熟悉的，它是一个内存数据库；因为它是内存数据库，并且内存的空间是有限的，如果Redis中数据量很大的话，内存就可能被占满，但是此时如果还有数据存入Redis的话，那该怎么办呢？这就是由Redis的的内存淘汰策略所决定的。</p><p>LRU最近最久未使用算法就是Redis的内存淘汰策略之一。 </p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前缓存的容量为2</span></span><br><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><h2 id="设计LRU算法的数据结构："><a href="#设计LRU算法的数据结构：" class="headerlink" title="设计LRU算法的数据结构："></a>设计LRU算法的数据结构：</h2><p>1、要求：<br>①、首先支持查询数据get和写入数据put；<br>②、满足时间复杂度为O(1)；</p><p>2、思路：<br>由题目中要求的O(1)时间复杂度想到缓存可以想到用一个map来存储key、value结点，最近最久未使用到的（缓存数据）放到最后，最新访问的（缓存数据）放到最前面，可以考虑用双向链表来实现，这样，这个map的key对应的是缓存的Key, value对应的是双向链表的一个节点，即链表的节点同时存在map的value中。</p><p>这样，当新插入一个节点时，它应该在这个双向链表的头结点处，同时把这个节点的key和这个节点put到map中保留下来。当LRU缓存链表容量达到最大又要插入新节点时，把链表的尾节点删除掉，同时在map中移除该节点对应的key。</p><p><strong>双向链表中节点的数据结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String key;</span><br><span class="line">Object value;</span><br><span class="line"><span class="comment">// 头指针</span></span><br><span class="line">DoubleLinkedListNode pre;</span><br><span class="line"><span class="comment">// 尾指针</span></span><br><span class="line">DoubleLinkedListNode next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedListNode</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由此可以抽象出LRU缓存算法的数据结构：双向链表+HashMap。</strong></p><p>数据结构逻辑图如下所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDMyMDEzNTkwNi5wbmc?x-oss-process=image/format,png" alt=""></p><h2 id="代码奉上："><a href="#代码奉上：" class="headerlink" title="代码奉上："></a>代码奉上：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, DoubleLinkedListNode&gt; map = <span class="keyword">new</span> HashMap&lt;String, DoubleLinkedListNode&gt;();</span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> DoubleLinkedListNode head;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">private</span> DoubleLinkedListNode tail;</span><br><span class="line"><span class="comment">// 双向链表的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">// 双向链表中节点的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 将节点设置为头结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(DoubleLinkedListNode node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 节点的尾指针执行头结点</span></span><br><span class="line">node.next = head;</span><br><span class="line"><span class="comment">// 节点的头指针置为空</span></span><br><span class="line">node.pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将头结点的头指针执行节点</span></span><br><span class="line">head.pre = node;</span><br><span class="line">&#125;</span><br><span class="line">head = node;</span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果双向链表中还没有节点时，头结点和尾节点都是当前节点</span></span><br><span class="line">tail = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:将双向链表中的节点移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DoubleLinkedListNode node)</span> </span>&#123;</span><br><span class="line">DoubleLinkedListNode cur = node;</span><br><span class="line">DoubleLinkedListNode pre = cur.pre;</span><br><span class="line">DoubleLinkedListNode post = cur.next;</span><br><span class="line"><span class="comment">// 如果当前节点没有头指针的话，说明它是链表的头结点</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">pre.next = post;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head = post;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点没有尾指针的话，说明当前节点是尾节点</span></span><br><span class="line"><span class="keyword">if</span> (post != <span class="keyword">null</span>) &#123;</span><br><span class="line">post.pre = pre;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tail = pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:从缓存Cache中get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用hashmap进行查询，时间复杂度为O(1)，如果进行链表查询，需要遍历链表，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">DoubleLinkedListNode node = map.get(key);</span><br><span class="line"><span class="comment">// 将查询出的节点从链表中移除</span></span><br><span class="line">removeNode(node);</span><br><span class="line"><span class="comment">// 将查询出的节点设置为头结点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存中没有要查询的内容</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:将key-value存储set到缓存Cache中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">DoubleLinkedListNode node = map.get(key);</span><br><span class="line">node.value = value;</span><br><span class="line">removeNode(node);</span><br><span class="line">setHead(node);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果缓存中没有词key-value</span></span><br><span class="line"><span class="comment">// 创建一个新的节点</span></span><br><span class="line">DoubleLinkedListNode newNode = <span class="keyword">new</span> DoubleLinkedListNode(key, value);</span><br><span class="line"><span class="comment">// 如果链表中的节点数小于链表的初始容量（还不需要进行数据置换）则直接将新节点设置为头结点</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">setHead(newNode);</span><br><span class="line"><span class="comment">// 将新节点放入hashmap中，用于提高查找速度</span></span><br><span class="line">map.put(key, newNode);</span><br><span class="line">size++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓存(双向链表)满了需要将"最近醉酒未使用"的节点(尾节点)删除，腾出新空间存放新节点</span></span><br><span class="line"><span class="comment">// 首先将map中的尾节点删除</span></span><br><span class="line">map.remove(tail.key);</span><br><span class="line"><span class="comment">// 移除尾节点并重新置顶尾节点的头指针指向的节点为新尾节点</span></span><br><span class="line">removeNode(tail);</span><br><span class="line"><span class="comment">// 将新节点设置为头节点</span></span><br><span class="line">setHead(newNode);</span><br><span class="line"><span class="comment">// 将新节点放入到map中</span></span><br><span class="line">map.put(key, newNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020年3月20日 下午1:39:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"双向链表的容量为6"</span>);</span><br><span class="line">LRUCache lc = <span class="keyword">new</span> LRUCache(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向缓存中插入set数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">lc.set(<span class="string">"test"</span> + i, <span class="string">"test"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 遍历缓存中的数据，从左到右，数据越不经常使用</span></span><br><span class="line">System.out.println(<span class="string">"第一次遍历双向链表：(从头结点遍历到尾节点)"</span>);</span><br><span class="line">DoubleLinkedListNode node = lc.head;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(node.key + <span class="string">"  "</span>);</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用get查询缓存中数据</span></span><br><span class="line">lc.get(<span class="string">"test2"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再次遍历缓存中的数据，从左到右，数据越不经常使用,并且此次发现刚刚操作的数据节点位于链表的头结点了。</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"get查询 test2节点后 ，第二次遍历双向链表："</span>);</span><br><span class="line">DoubleLinkedListNode node1 = lc.head;</span><br><span class="line"><span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(node1.key + <span class="string">"  "</span>);</span><br><span class="line">node1 = node1.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再次向缓存中插入数据，发现缓存链表已经满了，需要将尾节点移除</span></span><br><span class="line">lc.set(<span class="string">"sucess"</span>, <span class="string">"sucess"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 再次遍历缓存中的数据，从左到右，数据越不经常使用,并且此次发现刚刚set操作时由于链表满了， 就将尾节点test0</span></span><br><span class="line"><span class="comment"> * 移除了，并且将新节点置为链表的头结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"put插入sucess节点后，第三次遍历双向链表："</span>);</span><br><span class="line">DoubleLinkedListNode node2 = lc.head;</span><br><span class="line"><span class="keyword">while</span> (node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(node2.key + <span class="string">"  "</span>);</span><br><span class="line">node2 = node2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果展示："><a href="#运行结果展示：" class="headerlink" title="运行结果展示："></a>运行结果展示：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">双向链表容量为<span class="number">6</span></span><br><span class="line">第一次遍历双向链表：(从头结点遍历到尾节点)</span><br><span class="line">test5  test4  test3  test2  test1  test0  </span><br><span class="line"></span><br><span class="line">get查询 test2节点后 ，第二次遍历双向链表：</span><br><span class="line">test2  test5  test4  test3  test1  test0  </span><br><span class="line"></span><br><span class="line">put插入sucess节点后，第三次遍历双向链表：</span><br><span class="line">sucess  test2  test5  test4  test3  test1</span><br></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、<a href="https://blog.csdn.net/m0_37907797/article/details/104277209" target="_blank" rel="noopener">记一次阿里面试，我挂在了 最熟悉不过的LRU 缓存算法设计上。。。。。</a><br>2、 <a href="https://blog.csdn.net/qq_37372007/article/details/88418224" target="_blank" rel="noopener">【LeetCode】146. LRU缓存机制</a><br>3、<a href="https://www.cnblogs.com/springfor/p/3869393.html" target="_blank" rel="noopener">LRU Cache leetcode java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java使用Trie树算法实现敏感词替过滤、根据关键词自动联想</title>
      <link href="/2020/03/18/Java_Impl_Trie/"/>
      <url>/2020/03/18/Java_Impl_Trie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Trie树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的了。<br>然后可以根据它的公共前缀的特性来实现敏感词过滤、自动联想等功能。</p></blockquote><h2 id="抽象出trie树的数据结构："><a href="#抽象出trie树的数据结构：" class="headerlink" title="抽象出trie树的数据结构："></a>抽象出trie树的数据结构：</h2><p>1、首先来看下trie树的结构图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDMxODE0NTkwOS5wbmc?x-oss-process=image/format,png" alt=""><br><strong>从上图可以归纳出Trie树的基本性质：</strong><br>①根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>②从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>③每个节点的所有子节点包含的字符互不相同。<br>④从第一字符开始有连续重复的字符只占用一个节点，比如上面的to，和ten，中重复的单词t只占用了一个节点</p><p><strong>从上面归纳出的基本性质可以抽象出节点的class属性：</strong><br>1、是否为叶子节点的标志位  <span style="color:blue"><strong>isWord</strong></span> ；<br>2、既能存储此节点的值也能存储其所有的子节点的 <span style="color:blue"><strong>children</strong></span> 数据结构HashMap；</p><h2 id="代码奉上："><a href="#代码奉上：" class="headerlink" title="代码奉上："></a>代码奉上：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lyl.trie;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: trie树的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="comment">// 节点是否为叶子节点的标志；true：叶子节点，false：非叶子节点（用于子节点的节点）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line"><span class="comment">// 当前节点拥有的孩子节点，使用hashmap进行存储，在查找子节点时的时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Character, Node&gt; children;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.isWord = isWord;</span><br><span class="line"><span class="keyword">this</span>.children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// trie树的根节点</span></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">// trie树中拥有多少分枝（多少个敏感词）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 返回trie树中分枝树（敏感词树）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 向trie树中添加分枝/敏感词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> *            添加的敏感词</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBranchesInTrie</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置当前节点为根节点</span></span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words) &#123;</span><br><span class="line"><span class="comment">// 判断当前节点的子节点中是否存在字符c</span></span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line"><span class="comment">// 如果不存在则将其添加进行子节点中</span></span><br><span class="line">cur.children.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前节点进行变换，变换为新插入到节点 c</span></span><br><span class="line">cur = cur.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分枝添加完成后，将分枝中的最后一个节点设置为叶子节点</span></span><br><span class="line"><span class="keyword">if</span> (!cur.isWord) &#123;</span><br><span class="line">cur.isWord = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 分枝数（敏感词数）加1</span></span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 判断trie树中是否存在某分枝/敏感词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果存在并且遍历到trie树中某个分支最后一个节点了，那此节点就是叶子节点，直接返回true</span></span><br><span class="line"><span class="keyword">return</span> cur.isWord;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 如果一段话中有trie树中存储的敏感词则需将其进行替换为 **; 例如：尼玛的，替换为 **的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> *            一段话，如果有敏感词需要被替换的词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sensitiveWordReplace</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"敏感词替换前："</span> + word);</span><br><span class="line"> </span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"><span class="comment">// 需要被替换的敏感词</span></span><br><span class="line">StringBuilder oldTemp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 需要替换成的星号</span></span><br><span class="line">StringBuilder starTemp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line"><span class="comment">// 如果当前节点的孩子节点中没有此单词则直接跳过此循环，进入下次循环</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cur.isWord) &#123;</span><br><span class="line"><span class="comment">// 拼接上word和trie树都有的字符</span></span><br><span class="line">oldTemp.append(c);</span><br><span class="line">starTemp.append(<span class="string">"*"</span>);</span><br><span class="line">cur = cur.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.isWord) &#123;</span><br><span class="line"><span class="comment">// 进行敏感词替换</span></span><br><span class="line">word = word.replaceAll(oldTemp.toString(), starTemp.toString());</span><br><span class="line"><span class="comment">// 清空StringBuilder中内容</span></span><br><span class="line">oldTemp.delete(<span class="number">0</span>, oldTemp.length());</span><br><span class="line">starTemp.delete(<span class="number">0</span>, starTemp.length());</span><br><span class="line"><span class="comment">// 查找一个敏感词并替换后，需要重新从根节点进行遍历，所以当前节点指向root</span></span><br><span class="line">cur = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"敏感词替换后："</span> + word);</span><br><span class="line"><span class="keyword">return</span> word;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 存放trie树中查询到的联想词</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 利用trie的公共前缀特性，可以实现关键词自动联想</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prefixMatching</span><span class="params">(String word, Node root)</span> </span>&#123;</span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">str.append(word);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(words[i])) &#123;</span><br><span class="line">System.out.println(<span class="string">"无关联词！"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.children.get(words[i]);</span><br><span class="line">&#125;</span><br><span class="line">dfs(str, cur);</span><br><span class="line">System.out.println(<span class="string">"[ "</span> + word + <span class="string">" ]在trie树中的联想词："</span> + Arrays.toString(list.toArray()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 节点遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> *            需要查找的词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> *            开始遍历的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(StringBuilder word, Node root)</span> </span>&#123;</span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">if</span> (cur.isWord) &#123;</span><br><span class="line">list.add(word.toString());</span><br><span class="line"><span class="keyword">if</span> (cur.children.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Character s : cur.children.keySet()) &#123;</span><br><span class="line">word.append(s);</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line">dfs(word, cur.children.get(s));</span><br><span class="line">word.delete(word.length() - <span class="number">1</span>, word.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line"><span class="comment">// 插入敏感词</span></span><br><span class="line">t.addBranchesInTrie(<span class="string">"麻痹"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"尼玛的"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"狗日的"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 插入联想词</span></span><br><span class="line">t.addBranchesInTrie(<span class="string">"联想云科技"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"联盟"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"联和利泰扩招了"</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"trie树中分枝的个数："</span> + t.size);</span><br><span class="line"> </span><br><span class="line">String word = <span class="string">"尼玛的"</span>;</span><br><span class="line">System.out.println(<span class="string">"Trie树中是否存在[ "</span> + word + <span class="string">" ]敏感词: "</span> + t.contains(word));</span><br><span class="line"><span class="comment">// 敏感词替换测试</span></span><br><span class="line">t.sensitiveWordReplace(<span class="string">"衮，尼玛的傻子，你麻痹的，你各狗日的，早晚揍死你。"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// trie树实现联想测试</span></span><br><span class="line">t.prefixMatching(<span class="string">"联"</span>, t.root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码运行输出："><a href="#代码运行输出：" class="headerlink" title="代码运行输出："></a>代码运行输出：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trie树中分枝的个数：<span class="number">6</span></span><br><span class="line">Trie树中是否存在[ 尼玛的 ]敏感词: <span class="keyword">true</span></span><br><span class="line">敏感词替换前：衮，尼玛的傻子，你麻痹的，你各狗日的，早晚揍死你。</span><br><span class="line">敏感词替换后：衮，***傻子，你**的，你各***，早晚揍死你。</span><br><span class="line">[ 联 ]在trie树中的联想词：[联想云科技, 联和利泰扩招了, 联盟]</span><br></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、<a href="https://blog.csdn.net/m0_37907797/article/details/103272967" target="_blank" rel="noopener">【图解算法面试】记一次面试：说说游戏中的敏感词过滤是如何实现的？</a><br>2、 <a href="https://blog.csdn.net/u013309870/article/details/71081393?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">前缀树（Trie）原理及Java实现</a><br>3、<a href="https://blog.csdn.net/Nino_sama/article/details/100981325?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Trie树（字典树/前缀树）Java实现</a><br>4、<a href="https://www.wmathor.com/index.php/archives/1185/" target="_blank" rel="noopener">Trie 树实现搜索引擎自动联想 </a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中三目运算符的复杂使用方法</title>
      <link href="/2020/03/06/three_eys_complexUse/"/>
      <url>/2020/03/06/three_eys_complexUse/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java中三目运算符的复杂用法，让程序看起来更加简洁，但是代码易读性会降低。大家根据实际情况使用哟！</p></blockquote><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: ThreeEyeTest </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 好,你来了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>`s blog: https://leishen6.github.io/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeEyeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三目运算符的简单使用</span></span><br><span class="line">    String simple = i==<span class="number">10</span>?<span class="string">"true"</span>:<span class="string">"false"</span>;</span><br><span class="line">    System.out.println(simple);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三木运算符的复杂使用</span></span><br><span class="line">    String complex = i==<span class="number">1</span>?<span class="string">"a1"</span>:(i==<span class="number">2</span>?<span class="string">"a2"</span>:(i==<span class="number">3</span>?<span class="string">"a3"</span>:(i==<span class="number">10</span>?<span class="string">"a4"</span>:<span class="string">"a5"</span>)));</span><br><span class="line">    </span><br><span class="line">    System.out.println(complex);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>end</strong>—————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三目运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的位运算符</title>
      <link href="/2020/02/29/Java_run_operator/"/>
      <url>/2020/02/29/Java_run_operator/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>位运算符比一般的算术运算符速度要</strong>快，而且可以实现一些算术运算符不能实现的功能。如果要开发高效率程序，位运算符是必不可少的 。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位运算符用来对二进制位进行操作，包括：按位与（&amp;）、按位或（|）、按位异或（^）、按位取反（~）、按位左移（&lt;&lt;）、按位右移（&gt;&gt;）、按位无符号右移（&gt;&gt;&gt;）。</p></blockquote><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>例子：指定 A = 60（0011 1100）; B = 13 （0000 1101）</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9JbWFnZS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy93ZWlodW8ucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy95aWh1by5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9mYW4ucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy96dW95aS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy95b3V5aS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9ub3lvdXlpLnBuZw?x-oss-process=image/format,png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六大工具让你飞起，就问你它香不香！嘿嘿......</title>
      <link href="/2020/02/28/six_tool_fly/"/>
      <url>/2020/02/28/six_tool_fly/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>六大工具让你工作更加顺畅，生活更加甜蜜，快来瞅瞅并收藏哟！括弧(收藏不看系列不也挺香的呀，嘿嘿…..)</p></blockquote><h2 id="工具展示："><a href="#工具展示：" class="headerlink" title="工具展示："></a>工具展示：</h2><h5 id="1-印象笔记"><a href="#1-印象笔记" class="headerlink" title="1. 印象笔记"></a>1. 印象笔记</h5><p>这是一个记笔记的软件，肥肠好用，我从大学开始一直用到现在，现在推荐给大家；</p><p>注册的免费用户可以同时在两个终端进行登录，本人平时在笔记本、手机同时登录着，如果需要查询笔记看，可以拿起手机来就查询，你说它香不香，嘿嘿。</p><p>如果大家感觉同时两个终端登录还不够的话，例如有的大佬，需要在自己的台式机、mac本、平板、手机都同时登陆的话，那咱花钱升级账户，咱不差钱呢，哼！<br>[更多功能大家自己去探索哟。] &nbsp;&nbsp; 网址：<a href="https://www.yinxiang.com/" target="_blank" rel="noopener">https://www.yinxiang.com/</a></p><p><strong>上图：</strong> PC端软件长这个样，手机端大家可以自己去下载瞅瞅，反正挺香的！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy95aW54aWFuZy5wbmc?x-oss-process=image/format,png" alt=""></p><h5 id="2-Beyond-Compare-4"><a href="#2-Beyond-Compare-4" class="headerlink" title="2. Beyond Compare 4"></a>2. Beyond Compare 4</h5><p>Beyond Compare 4 主要用途是对比两个文件夹或者文件，并将差异以颜色标示。<br>其实它也可以用来进行比较两个版本不同的项目（指同一个项目，但是版本号不同）， 将其快速进行代码同步。</p><p>注：此软件有30天试用期的，大家可以在网上找些破解教程，很多的。</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="http://www.scootersoftware.com/download.php" target="_blank" rel="noopener">http://www.scootersoftware.com/download.php</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9iZXlvbmQucG5n?x-oss-process=image/format,png" alt=""></p><h5 id="3-JMeter"><a href="#3-JMeter" class="headerlink" title="3. JMeter"></a>3. JMeter</h5><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具，用于对软件做压力测试。</p><p>JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能；完全的可移植性和100% 纯java。</p><p>之前自己写了个监控系统，需要监控服务器的使用情况，后面就是使用的 JMeter 压服务器来得到监控数据的。括弧（后面会写一篇文章：java实现监控系统，敬请期待哟！）</p><p>最后再附上一份JMeter 的详细使用教程：<a href="https://www.cnblogs.com/testwjr/p/9156705.html" target="_blank" rel="noopener">https://www.cnblogs.com/testwjr/p/9156705.html</a>  </p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9qbWV0ZXIucG5n?x-oss-process=image/format,png" alt=""></p><h5 id="4-阿里巴巴矢量图标"><a href="#4-阿里巴巴矢量图标" class="headerlink" title="4. 阿里巴巴矢量图标"></a>4. 阿里巴巴矢量图标</h5><p>Iconfont-阿里巴巴矢量图标：国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能。</p><p>这对于前端攻城狮来说是非常棒的，并且对于我们全栈攻城狮也是不可或缺的。因为开发软件时经常会需要一些图标，如果自己制作的话耗时耗力；在知道了矢量图标库后，自己就可以直接去里面找符合自己心意的，省时省力，你说它不香吗，嘿嘿。</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9pY29uMS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9pY29uMi5wbmc?x-oss-process=image/format,png" alt=""></p><p>例如，本人的<a href="https://leishen6.github.io/">个人博客</a>中有很多图标就是从其中找的，我感觉挺香的呀！嘿嘿……  </p><p><strong>来来上图：</strong> (图中画圈的都是啊，大家看看香不香。)：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9ibG9nLnBuZw?x-oss-process=image/format,png" alt=""></p><h5 id="5-比特虫-在线制作ico图标"><a href="#5-比特虫-在线制作ico图标" class="headerlink" title="5. 比特虫 在线制作ico图标"></a>5. 比特虫 在线制作ico图标</h5><p>接下来，再介绍一个肥肠棒的<strong>在线制作ico图标</strong>的网站”<strong>比特虫</strong>“，它可将png、jpg等后缀的图片转为ico的图标。注意：在进行转化前选好图标的尺寸哟。大家可以去试试，我感觉挺香的，嘿嘿！</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="http://www.bitbug.net/" target="_blank" rel="noopener">http://www.bitbug.net/</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9iaXRjaG9uZy5wbmc?x-oss-process=image/format,png" alt=""></p><h5 id="6-processon-在线画图工具"><a href="#6-processon-在线画图工具" class="headerlink" title="6. processon 在线画图工具"></a>6. processon 在线画图工具</h5><p>processon 这个在线画图工具在我上大学时就使用的，我感觉它也是非常棒的，大家先瞅瞅它的官网；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9wcm9jZXNzT24ucG5n?x-oss-process=image/format,png" alt=""><br>上大学时，在<strong>Java实现爬虫</strong>的项目中使用 <strong>processon</strong> 画的流程图等，给大家瞅瞅，看看可以吗？</p><p><strong>先上第一张图</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9jcmF3bGVyX2ltZzEucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>来来第二张图</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9jcmF3bGVyX2ltZzIucG5n?x-oss-process=image/format,png" alt=""></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><blockquote><p>暂时就这些了，如果以后再遇到更好的工具时，会立即分享给大家，使我们大家工作顺畅，生活甜蜜！嘿嘿…..</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么数据脱敏及其实现方式</title>
      <link href="/2020/02/25/data_desensitization/"/>
      <url>/2020/02/25/data_desensitization/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据脱敏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发核心技术-幂等实现方案</title>
      <link href="/2020/02/25/power_etc/"/>
      <url>/2020/02/25/power_etc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>柔性事务与传统事务</title>
      <link href="/2020/02/25/flexible_transaction/"/>
      <url>/2020/02/25/flexible_transaction/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表策略，如何分库，如何分表？</title>
      <link href="/2020/02/24/DB_Sharding_Strategy/"/>
      <url>/2020/02/24/DB_Sharding_Strategy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全网最全redis学习脑图</title>
      <link href="/2020/02/21/redis_learn_mind_map/"/>
      <url>/2020/02/21/redis_learn_mind_map/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>本文为<span style="color:#2BFA05;"><strong>转载文章</strong></span>，转自一个<a href="https://blog.csdn.net/qq_35190492/category_9606008.html" target="_blank" rel="noopener">大佬</a>。分享一个全网最全的redis学习脑图。</p></blockquote><h2 id="redis脑图："><a href="#redis脑图：" class="headerlink" title="redis脑图："></a>redis脑图：</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9SZWRpcyVFNSVBRCVBNiVFNCVCOSVBMCVFOCU4NCU5MSVFNSU5QiVCRS5qcGc?x-oss-process=image/format,png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 非关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实现使用 _DESede_ 对称加密的 加解密工具类</title>
      <link href="/2020/02/18/java_imp_DESede_%20util/"/>
      <url>/2020/02/18/java_imp_DESede_%20util/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java实现 “DESede” 对称加密；</p></blockquote><h2 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h2><blockquote><p>在代码运行前，需要提前将一个依赖导入到项目中 pom.xml 中，使用这个依赖中的base64进行编解码；</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- base64编码使用 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESedeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密钥算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"DESede"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加密/解密算法 / 工作模式 / 填充方式</span></span><br><span class="line"><span class="comment"> * Java 6支持PKCS5Padding填充方式</span></span><br><span class="line"><span class="comment"> * Bouncy Castle支持PKCS7Padding填充方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"DESede/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生成密钥, 返回168位的密钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//实例化密钥生成器</span></span><br><span class="line">KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line"><span class="comment">//DESede 要求密钥长度为 112位或168位</span></span><br><span class="line">kg.init(<span class="number">168</span>);</span><br><span class="line"><span class="comment">//生成密钥</span></span><br><span class="line">SecretKey secretKey = kg.generateKey();</span><br><span class="line"><span class="comment">//获得密钥的字符串形式</span></span><br><span class="line"><span class="keyword">return</span> Base64.encodeBase64String(secretKey.getEncoded());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: DES进行加密</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source 待加密的原字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  加密时使用的 密钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   返回经过base64编码的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String source, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] sourceBytes = source.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE,<span class="keyword">new</span> SecretKeySpec(keyBytes, KEY_ALGORITHM));</span><br><span class="line">    <span class="keyword">byte</span>[] decrypted = cipher.doFinal(sourceBytes);</span><br><span class="line">    <span class="keyword">return</span> Base64.encodeBase64String(decrypted);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:  DES解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr  DES加密后的再经过base64编码的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  加密使用的密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回 utf-8 编码的明文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptStr, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] sourceBytes = Base64.decodeBase64(encryptStr);</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE,<span class="keyword">new</span> SecretKeySpec(keyBytes, KEY_ALGORITHM));</span><br><span class="line">    <span class="keyword">byte</span>[] decoded = cipher.doFinal(sourceBytes);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(decoded, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 生成秘钥</span></span><br><span class="line">        String key = generateKey();</span><br><span class="line">        System.out.println(<span class="string">"秘钥："</span>+key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        String encryptStr = encrypt(<span class="string">"hello"</span>, key);</span><br><span class="line">        System.out.println(<span class="string">"密文："</span>+ encryptStr);</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        String resource = decrypt(encryptStr, key);</span><br><span class="line">        System.out.println(<span class="string">"明文："</span>+ resource);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"校验："</span>+ <span class="string">"hello"</span>.equals(resource));</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 amcharts.js 实现立体柱状图</title>
      <link href="/2020/02/15/imp_histogram_byAmcharts/"/>
      <url>/2020/02/15/imp_histogram_byAmcharts/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p> 本文章将使用<span style="color:red;"> <strong>amcharts.js</strong> </span>实现立体柱状图，以下代码中的js库是直接引入网络中的js文件，所以代码拷贝下来是可以直接运行的。</p></blockquote><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDE5MTIxODE0MTYyNjUzOC5wbmc?x-oss-process=image/format,png" alt=""></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;立体柱状图&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 立体柱状图 --&gt;</span><br><span class="line">&lt;script src="https://www.amcharts.com/lib/3/amcharts.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src="https://www.amcharts.com/lib/3/serial.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div id=<span class="string">"car3"</span> style=<span class="string">"text-align:center;width:440px;height:180px;"</span>&gt;</span><br><span class="line"> &lt;script type=<span class="string">"text/javascript"</span>&gt;      </span><br><span class="line"> <span class="keyword">var</span> chartData = [&#123; country: <span class="string">"订单未确定"</span>, visits: <span class="number">50</span> , <span class="string">"color"</span>: <span class="string">"#067ADD"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单已确定"</span>, visits: <span class="number">166</span> , <span class="string">"color"</span>: <span class="string">"#FA0606"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单已处理"</span>, visits: <span class="number">26</span>  , <span class="string">"color"</span>: <span class="string">"#14EF06"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单完成"</span>, visits: <span class="number">80</span> , <span class="string">"color"</span>: <span class="string">"#F802BC"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单已发货"</span>, visits: <span class="number">56</span> , <span class="string">"color"</span>: <span class="string">"#0FFBF9"</span>&#125;,</span><br><span class="line">   ];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> chart = <span class="keyword">new</span> AmCharts.AmSerialChart();</span><br><span class="line"> chart.dataProvider = chartData;</span><br><span class="line"> chart.categoryField = <span class="string">"country"</span>;<span class="comment">//获取"chartData"中的文本内容</span></span><br><span class="line"> chart.color = <span class="string">"#4C4CFD"</span>; <span class="comment">//标题颜色（x、y轴的字体颜色）</span></span><br><span class="line"> chart.startDuration = <span class="number">2</span>;  <span class="comment">//动画特效 延迟时间 秒  </span></span><br><span class="line"> chart.columnWidth = <span class="number">0.4</span>; <span class="comment">//柱状图宽度</span></span><br><span class="line"> chart.depth3D = <span class="number">8</span>;<span class="comment">//3D厚度</span></span><br><span class="line"> chart.angle = <span class="number">30</span>;</span><br><span class="line"> chart.depth3D = <span class="number">15</span>;<span class="comment">//控制列的深度和角度</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> categoryAxis = chart.categoryAxis;</span><br><span class="line"> categoryAxis.gridColor = <span class="string">"#067ADD"</span>; <span class="comment">//网格线颜色</span></span><br><span class="line"> categoryAxis.axisColor = <span class="string">"#067ADD"</span>;  <span class="comment">//横坐标轴颜色</span></span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> valueAxis = <span class="keyword">new</span> AmCharts.ValueAxis();  <span class="comment">//纵坐标轴</span></span><br><span class="line"> valueAxis.axisColor = <span class="string">"#067ADD"</span>;  <span class="comment">//纵坐标轴轴线的颜色</span></span><br><span class="line"> chart.addValueAxis(valueAxis);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> graph = <span class="keyword">new</span> AmCharts.AmGraph();</span><br><span class="line"> graph.valueField = <span class="string">"visits"</span> ; <span class="comment">//获取"chartData"中的数量</span></span><br><span class="line"> graph.colorField = <span class="string">"color"</span>;<span class="comment">//获取"chartData"中的配置颜色</span></span><br><span class="line"> <span class="comment">//graph.lineColor = "#067ADD";//柱状图的颜色,这里是全部设置成为统一 #067ADD 颜色</span></span><br><span class="line"> <span class="comment">//graph.topRadius = 1;   //设置为椭圆柱体,默认是长方形柱体</span></span><br><span class="line"> graph.lineAlpha = <span class="number">0.1</span>;</span><br><span class="line"> graph.fillAlphas = <span class="number">0.85</span>;</span><br><span class="line"> graph.type = <span class="string">"column"</span>;<span class="comment">//柱形，也可是设置为 line 折线图等</span></span><br><span class="line"> chart.addGraph(graph);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> graph.fillAlphas = <span class="number">1</span>;<span class="comment">//填充柱形图的颜色</span></span><br><span class="line"> graph.balloonText = <span class="string">"&lt;b&gt;[[category]]: [[value]] 单&lt;/b&gt;"</span>;<span class="comment">//鼠标悬浮时展示数据的格式</span></span><br><span class="line"> </span><br><span class="line"> chart.write(<span class="string">'car3'</span>); <span class="comment">//将js写入到div容器中</span></span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试手写HashMap，手撕HashMap</title>
      <link href="/2020/02/12/interview_Implement_HashMap/"/>
      <url>/2020/02/12/interview_Implement_HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>现在面试时，面试官经常会问到HashMap，简单点就会问下HashMap的一些关键知识点，困难些的可能会当场让你手写一个HashMap，考察下你对HashMap底层原理的了解深度；所以，今天特别手写了一个简单的HashMap，只实现了<span style="color:red;"> put、get、containsKey、keySet </span>方法的 HashMap，来帮助我们理解HashMap的底层设计原理。<br>本文参考：<a href="https://blog.csdn.net/huangshulang1234/article/details/79713303" target="_blank" rel="noopener">手写实现一个HashMap</a></p></blockquote><h2 id="手撕HashMap："><a href="#手撕HashMap：" class="headerlink" title="手撕HashMap："></a>手撕HashMap：</h2><h4 id="1-首先定义接口："><a href="#1-首先定义接口：" class="headerlink" title="1. 首先定义接口："></a>1. 首先定义接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Title</span>: MyMap </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义map接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午3:56:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 插入键值对方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午3:59:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k,V v)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:根据key获取value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午3:59:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 判断key键是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k  key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午4:07:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取map集合中所有的key，并放入set集合中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午4:24:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt;  <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------内部接口 Entry（存放key-value）---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Enter </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 定义内部接口 Entry，存放键值对的Entery接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午4:00:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取key方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午4:02:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:获取value方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午4:02:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-接口实现类："><a href="#2-接口实现类：" class="headerlink" title="2. 接口实现类："></a>2. 接口实现类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Title</span>: MyHashMap </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:   MyMap接口的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午4:04:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>,<span class="string">"rawtypes"</span>,<span class="string">"hiding"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry数组的默认初始化长度为16；通过位移运算向左移动四位，得到二进制码 "00010000",转换为十进制是16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子默认为0.75f；负载因子是用来标志当使用容量占总容量的75%时，就需要扩充容量了，</span></span><br><span class="line"><span class="comment"> * 扩充Entry数组的长度为原来的两倍，并且重新对所存储的key-value键值对进行散列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可设置的初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultInitSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可设置的负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> defaultLoadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前已存入的元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> entryUseSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放key-value键值对对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K, V&gt;[] table = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造，数组初始大小为16，负载因子大小为0.75f</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY,DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造，自己设置数组初始大小和负载因子大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultInitialCapacity  数组初始大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultLoadFactor2    负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> defaultInitialCapacity, <span class="keyword">float</span> defaultLoadFactor2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断初始容量参数是否合法</span></span><br><span class="line"><span class="keyword">if</span> (defaultInitialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//抛出非法参数异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的初始容量参数是非法的  ："</span>+defaultInitialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断负载因子参数是否合法，Float.isNaN()方法是判断数据是否符合 0.0f/0.0f</span></span><br><span class="line"><span class="keyword">if</span> (defaultLoadFactor2 &lt; <span class="number">0</span> || Float.isNaN(defaultLoadFactor2)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的负载因子参数是非法的  ："</span>+defaultLoadFactor2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.defaultInitSize = defaultInitialCapacity;</span><br><span class="line"><span class="keyword">this</span>.defaultLoadFactor = defaultLoadFactor2;</span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line">table = <span class="keyword">new</span> Entry[<span class="keyword">this</span>.defaultInitSize];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 集合中的put方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如是更新则返回key的旧value值，如是插入新的key-value则返回null</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午6:29:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">V oldValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//是否需要扩容？</span></span><br><span class="line"><span class="comment">//扩容完毕后一定会需要重新进行散列</span></span><br><span class="line"><span class="keyword">if</span> (entryUseSize &gt;= defaultInitSize * defaultLoadFactor) &#123;</span><br><span class="line"><span class="comment">//扩容并重新散列,扩容为原来的两倍</span></span><br><span class="line">resize(<span class="number">2</span> * defaultInitSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据key获取的HASH值、数组长度减1，两者做'与'运算，计算出数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> index = hash(k) &amp; (defaultInitSize -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//如果数组中此下标位置没有元素的话，就直接放到此位置上</span></span><br><span class="line"><span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">table[index] = <span class="keyword">new</span> Entry(k, v, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//总存入元素数量+1</span></span><br><span class="line">++entryUseSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//遍历数组下边的链表</span></span><br><span class="line">Entry&lt;K,V&gt; entry = table[index];</span><br><span class="line">Entry&lt;K,V&gt; e = entry;</span><br><span class="line"><span class="keyword">while</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (k == e.getKey() || k.equals(e.getKey())) &#123;</span><br><span class="line">oldValue = e.getValue();</span><br><span class="line"><span class="comment">//key已存在，直接更新value</span></span><br><span class="line">e.value = v;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组此下标位置上链表的下个元素</span></span><br><span class="line">e = e.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK1.7中的链表头插法，直接占据数组下标位置</span></span><br><span class="line">    table[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(k, v, entry);</span><br><span class="line">    <span class="comment">//总存入元素数量+1</span></span><br><span class="line">    ++entryUseSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据key获取value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午6:34:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过hash函数和数组元素容量做  【与】运算得到数组下标</span></span><br><span class="line"><span class="keyword">int</span> index = hash(k) &amp; (defaultInitSize -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//获取到数组下标位置元素</span></span><br><span class="line">Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">Entry&lt;K, V&gt; e = entry;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k.equals(e.getKey())) &#123;</span><br><span class="line"><span class="keyword">return</span> e.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组下标位置对应链表中的下一个元素</span></span><br><span class="line">e = e.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:扩容并重新将元素进行散列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i  扩容后的大小</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午5:06:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">Entry&lt;K,V&gt;[] newTable = <span class="keyword">new</span> Entry[size];</span><br><span class="line"><span class="comment">//改变数组的初始大小</span></span><br><span class="line">defaultInitSize = size ;</span><br><span class="line"><span class="comment">//将已存放键值对数量置为0</span></span><br><span class="line">entryUseSize = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//将已存的元算根据最新的数组的大小进行散列</span></span><br><span class="line">rehash(newTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 重新进行散列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newTable</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午5:10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(Entry&lt;K, V&gt;[] newTable)</span></span>&#123;</span><br><span class="line">List&lt;Entry&lt;K, V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; entry : table)&#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//将原来数组中的元素放到list集合中</span></span><br><span class="line">entryList.add(entry);</span><br><span class="line"><span class="comment">//如果此数组下标的位置存在链表的话，需要遍历下列表，将列表中的键值对数据取出来放到集合中</span></span><br><span class="line">entry = entry.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将旧的数组引用覆盖，让引用指向堆中新开辟的数组</span></span><br><span class="line"><span class="keyword">if</span> (newTable.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所谓重新的散列hash，就是将元素重新放入到扩容后的集合中</span></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; entry : entryList)&#123;</span><br><span class="line"><span class="comment">//重新put</span></span><br><span class="line">put(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据key获取hashcod码值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午5:52:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 判断是否存在此key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k  key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午4:52:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = hash(k) &amp; (defaultInitSize -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//获取到数组下标位置元素</span></span><br><span class="line">Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">Entry&lt;K, V&gt; e = entry;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k.equals(e.getKey())) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组下标位置对应链表中的下一个元素</span></span><br><span class="line">e = e.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flag; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取map集合所有的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午5:52:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entryUseSize == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;K&gt; entrySet = <span class="keyword">new</span> HashSet&lt;K&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; entry : table)&#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//将原来数组中的元素的key放到set集合中</span></span><br><span class="line">entrySet.add(entry.getKey());</span><br><span class="line"><span class="comment">//如果此数组下标的位置存在链表的话，需要遍历下列表，将列表中元素的key取出来放到集合中</span></span><br><span class="line">entry = entry.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------内部类 Entry（存放key-value）----------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Entry </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 实现了key-value简直对接口的java类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午6:12:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对对象的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> K key;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对对象的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span>  V value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对对象指向下一个键值对对象的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-测试方法："><a href="#3-测试方法：" class="headerlink" title="3. 测试方法："></a>3. 测试方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: TestMyMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午6:49:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:单元测试</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午7:07:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyMap&lt;String, String&gt; map = <span class="keyword">new</span> MyHashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//插入键值对</span></span><br><span class="line">map.put(<span class="string">"key"</span> + i, <span class="string">"value"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"key"</span> + i + <span class="string">",value is："</span> + map.get(<span class="string">"key"</span> + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取value</span></span><br><span class="line">System.out.println(<span class="string">"\n"</span>+<span class="string">"此key：key88 的value是   "</span>+map.get(<span class="string">"key88"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断key是否存在</span></span><br><span class="line">    System.out.println(map.containsKey(<span class="string">"key885"</span>)+<span class="string">"   此key：key885 不存在！"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取map集合中所有的key</span></span><br><span class="line">    System.out.println(Arrays.toString(map.keySet().toArray()));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    MyMap&lt;String, String&gt; mapOther = <span class="keyword">new</span> MyHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; keySet = mapOther.keySet();</span><br><span class="line">    <span class="comment">//获取map集合中所有的key</span></span><br><span class="line">    System.out.println((keySet == <span class="keyword">null</span>)?<span class="keyword">null</span>:Arrays.toString(mapOther.keySet().toArray()));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo+Zookeeper vs Spring Cloud 之间的比较</title>
      <link href="/2020/02/12/Dubbo_Zookeeper%20_vs_SpringCloud/"/>
      <url>/2020/02/12/Dubbo_Zookeeper%20_vs_SpringCloud/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>目前学习了下Dubbo 和  Spring Cloud，并且在简单学习后，总结了下这两者之间简单的区别；如果以后有需要搭建分布式系统的需求，可以根据这两者之间的区别，再根据当前公司的业务等情况选择最为合适的来搭建自己的分布式系统。</p></blockquote><h2 id="Dubbo-Zookeeper-vs-Spring-Cloud："><a href="#Dubbo-Zookeeper-vs-Spring-Cloud：" class="headerlink" title="Dubbo+Zookeeper   vs   Spring Cloud："></a>Dubbo+Zookeeper   <span style="color:red;"><strong>vs</strong></span>   Spring Cloud：</h2><table><thead><tr><th>框架比较的方面</th><th>Dubbo+Zookeeper</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>性能方面</td><td>Dubbo是阿里巴巴开源的顶级项目，以前是用于阿里巴巴的分布式服务治理框架,其性能毋庸置疑一定是很强的，它适合一些比较大的公司用的分布式服务治理框架。（注：2017年之前阿里巴巴没有对其进行更新维护，但是2017年Dubbo项目官网宣布重新对其进行更新维护，并且在2018年Dubbo项目正式进入了Apache孵化器）</td><td>Spring Cloud是最近才兴起的一个分布式服务框架，现在它的社区十分的火爆，代码的更新迭代十分的快；它一般适合于中小型企业，并且性能比Dubbo低一些；</td></tr><tr><td>具有的特点</td><td>Dubbo有良好的连通性、健壮性、伸缩性、升级性。结合Dubbo可以相对于单体系统提升系统整体的扩展性。<br> Dubbo提供了多种协议给用户选择， 如dubbo、hessian、rmi 。 并可为每个服务指定不同的传输协议，粒度可以细化到方法， 不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议。</td><td>Spring Cloud来源于Spring，质量、稳定性、持续性都可以得到保证。<br>Spirng Cloud天然支持Spring Boot，更加便于业务落地。<br>Spring Cloud是Java领域最适合做微服务的框架。<br>相比于其它框架,Spring Cloud对微服务周边环境的支持力度最大。</td></tr><tr><td>方便性</td><td>Dubbo使用起来不太方便，由于许多组件其本身不支持，所以我们在搭建架构环境时，需要集成一些其他的开源组件，集成时会遇到种种的困难，并且在以后的项目维护和升级也不方便。<br>Dubbo服务调用的方式是RPC，服务提供方与调用方接口依赖方式太强：我们需要将调用的抽象接口依赖到消费者项目中才能调用服务，这会导致在以后的开发、测试、版本管理上很麻烦。</td><td>pringCloud自身的组件可以搭建成一个完整的微服务架构，并且搭建起来稍微简单一些；<br>SpringCloud调用的方式是REST，REST接口相比RPC更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然REST接口也有缺点，很容易导致定义文档与实际实现不一致导致服务集成时的问题。</td></tr><tr><td>灵活性</td><td>由于dubbo许多组件都是集成的第三方，所以dubbo组件之间的自由度很高，dubbo更加的灵活。</td><td>SpringCloud自身支持了组件，各个组件之间的关联关系已经配置好了，所以它的灵活度不是很好，如果想要用第三方组件代替其中的一个组件的话会有一些困难。</td></tr><tr><td>服务注册中心</td><td>Zookeeper保证<span style="color:red;">C(一致性)P(分区容错性)</span>。<br>当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。</td><td>Eureka保证<span style="color:red;">A(可用性)P(分区容错性)</span>。<br>Eureka各个节点都是平等的，几个节点挂掉不会影响正常工作。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)</td></tr><tr><td>代码开发角度</td><td>Dubbo常与Spring、zookeeper结合，而且实现只是通过xml来配置服务地址、名称、端口，代码的侵入性是很小的，可以说几乎没有代码入侵。</td><td>Spring Cloud，由于它的实现需要类注解等，所以多少具有一定代码侵入。</td></tr></tbody></table><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总的来说这两个搭建分布式系统的框架各有各的好处，在选择时要根据自己的需求等情况综合做选择；<br> 但是Eureka作为单纯的服务注册中心来说感觉要比Zookeeper更加<span style="color:red;">“<strong>专业</strong>”</span>，因为注册服务更重要的是高可用性，可以接受短期内达不到一致性的状况。</p><p> <span style="color:red;"><strong>注：</strong></span>可能此文章中表格内容看起来不太舒服，你还可以参考我在CSDN中的<a href="https://blog.csdn.net/feichitianxia/article/details/92682828" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 集群分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> Zookeeper </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现 “ 将数字金额转为大写中文金额 ”</title>
      <link href="/2020/02/09/Java_imp_chinease_monery/"/>
      <url>/2020/02/09/Java_imp_chinease_monery/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>输入数字金额参数，运行程序得到其对应的大写中文金额；例如：输入— 12.56，输出— 12.56:壹拾贰元伍角陆分；重点来了：<span style="color:red;"><strong><em>本人亲测有效</em></strong></span>。</p></blockquote><h2 id="奉上代码："><a href="#奉上代码：" class="headerlink" title="奉上代码："></a>奉上代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Title</span>: ConvertUpMoney </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  将数字金额转为大写汉字金额</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年6月18日 下午10:52:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertUpMoney</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大写数字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NUMBERS = &#123;<span class="string">"零"</span>,<span class="string">"壹"</span>,<span class="string">"贰"</span>,<span class="string">"叁"</span>,<span class="string">"肆"</span>,<span class="string">"伍"</span>,<span class="string">"陆"</span>,<span class="string">"柒"</span>,<span class="string">"捌"</span>,<span class="string">"玖"</span>&#125;;</span><br><span class="line"><span class="comment">// 整数部分的单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] IUNIT = &#123;<span class="string">"元"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>,<span class="string">"万"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>,<span class="string">"亿"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>,<span class="string">"万"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>&#125;;</span><br><span class="line">    <span class="comment">//小数部分的单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DUNIT = &#123;<span class="string">"角"</span>,<span class="string">"分"</span>,<span class="string">"厘"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转成中文的大写金额</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toChinese</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断输入的金额字符串是否符合要求</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(str) || !str.matches(<span class="string">"(-)?[\\d]*(.)?[\\d]*"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"抱歉，请输入数字！"</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"0"</span>.equals(str) || <span class="string">"0.00"</span>.equals(str) || <span class="string">"0.0"</span>.equals(str)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"零元"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在负号"-"</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(str.startsWith(<span class="string">"-"</span>))&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">str = str.replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str = str.replaceAll(<span class="string">","</span>, <span class="string">""</span>);<span class="comment">//去掉","</span></span><br><span class="line">String integerStr;<span class="comment">//整数部分数字</span></span><br><span class="line">String decimalStr;<span class="comment">//小数部分数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化：分离整数部分和小数部分</span></span><br><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">"."</span>)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">integerStr = str.substring(<span class="number">0</span>,str.indexOf(<span class="string">"."</span>));</span><br><span class="line">decimalStr = str.substring(str.indexOf(<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.indexOf(<span class="string">"."</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">integerStr = <span class="string">""</span>;</span><br><span class="line">decimalStr = str.substring(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">integerStr = str;</span><br><span class="line">decimalStr = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//beyond超出计算能力，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(integerStr.length()&gt;IUNIT.length) &#123;</span><br><span class="line">System.out.println(str+<span class="string">"：超出计算能力"</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] integers = toIntArray(integerStr);<span class="comment">//整数部分数字</span></span><br><span class="line"><span class="comment">//判断整数部分是否存在输入012的情况</span></span><br><span class="line"><span class="keyword">if</span> (integers.length&gt;<span class="number">1</span> &amp;&amp; integers[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"抱歉，请输入数字！"</span>);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">str = <span class="string">"-"</span>+str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> isWan = isWan5(integerStr);<span class="comment">//设置万单位</span></span><br><span class="line"><span class="keyword">int</span>[] decimals = toIntArray(decimalStr);<span class="comment">//小数部分数字</span></span><br><span class="line">String result = getChineseInteger(integers,isWan)+getChineseDecimal(decimals);<span class="comment">//返回最终的大写金额</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"负"</span>+result;<span class="comment">//如果是负数，加上"负"</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串转为int数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] toIntArray(String number) &#123;</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[number.length()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;number.length();i++) &#123;</span><br><span class="line">array[i] = Integer.parseInt(number.substring(i,i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将整数部分转为大写的金额</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChineseInteger</span><span class="params">(<span class="keyword">int</span>[] integers,<span class="keyword">boolean</span> isWan)</span> </span>&#123;</span><br><span class="line">StringBuffer chineseInteger = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">int</span> length = integers.length;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">1</span> &amp;&amp; integers[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(integers[i] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>((length - i) == <span class="number">13</span>)<span class="comment">//万（亿）</span></span><br><span class="line">key = IUNIT[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((length - i) == <span class="number">9</span>) &#123;<span class="comment">//亿</span></span><br><span class="line">key = IUNIT[<span class="number">8</span>];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((length - i) == <span class="number">5</span> &amp;&amp; isWan) &#123;<span class="comment">//万</span></span><br><span class="line">key = IUNIT[<span class="number">4</span>];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((length - i) == <span class="number">1</span>) &#123;<span class="comment">//元</span></span><br><span class="line">key = IUNIT[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((length - i)&gt;<span class="number">1</span> &amp;&amp; integers[i+<span class="number">1</span>]!=<span class="number">0</span>) &#123;</span><br><span class="line">key += NUMBERS[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chineseInteger.append(integers[i]==<span class="number">0</span>?key:(NUMBERS[integers[i]]+IUNIT[length - i -<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chineseInteger.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将小数部分转为大写的金额</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getChineseDecimal</span><span class="params">(<span class="keyword">int</span>[] decimals)</span> </span>&#123;</span><br><span class="line">StringBuffer chineseDecimal = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;decimals.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">chineseDecimal.append(decimals[i]==<span class="number">0</span>?<span class="string">""</span>:(NUMBERS[decimals[i]]+DUNIT[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chineseDecimal.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前整数部分是否已经是达到【万】</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isWan5</span><span class="params">(String integerStr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = integerStr.length();</span><br><span class="line"><span class="keyword">if</span>(length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">String subInteger = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(length &gt; <span class="number">8</span>) &#123;</span><br><span class="line">subInteger = integerStr.substring(length- <span class="number">8</span>,length -<span class="number">4</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">subInteger = integerStr.substring(<span class="number">0</span>,length - <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(subInteger) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String number = <span class="string">"12.56"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"1234567890563886.123"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"1600"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"156,0"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"-156,0"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"0.12"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"0.0"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"01.12"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"0125"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"-0125"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"sdw5655"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">null</span>+<span class="string">": "</span>+ConvertUpMoney.toChinese(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加个彩蛋："><a href="#加个彩蛋：" class="headerlink" title="加个彩蛋："></a>加个彩蛋：</h2><blockquote><p>本人在平时的学习中，还看到了一个十分有用的工具包，这个工具包中含有一个类型转换的方法，可以实现“ 金额的大小写 ”，但是这个工具包也有一些局限，“ 转换为大写只能精确到分（<span style="color:red;"><strong>小数点儿后两位</strong></span>），之后的数字会被忽略 ”；这个工具包叫“ <span style="color:red;"><strong>Hutool</strong></span> ”，学习地址：<a href="https://www.hutool.cn/docs/#/core/类型转换/类型转换工具类-Convert" target="_blank" rel="noopener">https://www.hutool.cn/docs/#/core/类型转换/类型转换工具类-Convert</a>  。</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒汉式单例模式为什么要进行二次判空</title>
      <link href="/2020/02/08/singleton_twoIfNull_reason/"/>
      <url>/2020/02/08/singleton_twoIfNull_reason/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>在本文中会使用代码进行展示懒汉单例模式为什么需要进行二次判空；代码中使用到 <span style="color:red;"><strong>CountDownLatch 倒计时器</strong></span>，不清楚CountDownLatch 使用的请参考此文<a href="https://www.jianshu.com/p/f17692e9114f" target="_blank" rel="noopener">“倒计时器：CountDownLatch”</a> 。</p></blockquote><h2 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h2><h5 id="1、懒汉式单例模式类"><a href="#1、懒汉式单例模式类" class="headerlink" title="1、懒汉式单例模式类"></a>1、懒汉式单例模式类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用volatile禁止指令重排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton sin = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 标识有几个线程获取到了锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">// 标识系统中到底生成了几个实例</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将构造器的修饰符设置为"private"，可以防止在外部进行new实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取实例对象的方法，公共的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一次判空。</span></span><br><span class="line"><span class="keyword">if</span> (sin == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 第二次判空。</span></span><br><span class="line"><span class="keyword">if</span> (sin == <span class="keyword">null</span>) &#123;</span><br><span class="line">sin = <span class="keyword">new</span> Singleton();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sin;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、多线程并发调用单例模式的测试类"><a href="#2、多线程并发调用单例模式的测试类" class="headerlink" title="2、多线程并发调用单例模式的测试类"></a>2、多线程并发调用单例模式的测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个倒计树器,初始倒计数为10</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadTest demo = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//实例对象生成</span></span><br><span class="line">Singleton.getInstance();</span><br><span class="line"><span class="comment">//输出当前线程的名称</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//计数器进行减一</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//创建一个长度为10的定长线程池</span></span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待检查,阻塞main主线程,只有当CountDownLatch倒计数器为0时才会唤醒阻塞的main主线程</span></span><br><span class="line">        latch.await();  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开启的10个线程中几个线程获取到了锁</span></span><br><span class="line">System.out.println(<span class="string">"共有 ( "</span> + Singleton.i + <span class="string">" ) 个线程获取到对象锁"</span>);</span><br><span class="line"><span class="comment">// 最终生成了几个Singleton实例</span></span><br><span class="line">System.out.println(<span class="string">"最终生成了( "</span> + Singleton.j + <span class="string">" )个Singleton实例对象"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行上面的mian方法，会得到以下的一种输出结果-存在多种输出结果"><a href="#运行上面的mian方法，会得到以下的一种输出结果-存在多种输出结果" class="headerlink" title="运行上面的mian方法，会得到以下的一种输出结果(存在多种输出结果)"></a>运行上面的mian方法，会得到以下的一种输出结果(存在多种输出结果)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span></span><br><span class="line">共有 ( <span class="number">2</span> ) 个线程获取到对象锁</span><br><span class="line">最终生成了( <span class="number">1</span> )个Singleton实例对象</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> 从运行结果可以看出，如果不进行第二次判空的话，那么在<span style="color:red;">竟锁池(锁池)</span>中如果还有活跃的线程在等待获取的锁的话，在锁释放后就会再次竞争获取锁，获取的锁的线程进入”就绪状态”，当cpu分配其”时间片”后进行线程的调度，从而线程进入”运行中状态”，并会去执行同步的代码块，如果在没加如二次判空的话，就会导致系统中存在多个实例，而在进行判空后，即使你获取到了锁，但在执行同步代码块时也会直接跳过。</p><pre><code>竟锁池(锁池)的概念：[“倒计时器：CountDownLatch”](https://blog.csdn.net/qq_22498277/article/details/82184419)</code></pre><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本查询服务器的cpu、内存、磁盘的使用率</title>
      <link href="/2020/02/07/search_cpu_memery_disk_byShell/"/>
      <url>/2020/02/07/search_cpu_memery_disk_byShell/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>使用shell脚本查询服务器的cpu、内存、磁盘的使用率；如果需要对此脚本进行理解的话，请首先熟悉下<a href="https://blog.csdn.net/feichitianxia/article/details/103088793" target="_blank" rel="noopener">linux的基本命令和管道符的知识</a>。</p></blockquote><h2 id="脚本献上："><a href="#脚本献上：" class="headerlink" title="脚本献上："></a>脚本献上：</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#计算cpu使用率, -n number：指定在结束前应该产生的最大迭代次数或帧数,一般迭代次数越大，获取到的cpu使用率越准确; 本脚本中是迭代了5次，"-n5" </span></span><br><span class="line">cpu=`top <span class="literal">-b</span> <span class="literal">-n5</span> | fgrep <span class="string">"Cpu(s)"</span> | tail <span class="literal">-1</span> | awk <span class="operator">-F</span><span class="string">'id,'</span> <span class="string">'&#123;split($1, vs, ","); v=vs[length(vs)]; sub(/\s+/, "", v);sub(/\s+/, "", v); printf "%d", 100-v;&#125;'</span>`</span><br><span class="line">echo <span class="variable">$cpu</span><span class="string">'%'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#统计内存使用率</span></span><br><span class="line">mem_used_persent=`free <span class="literal">-m</span> | awk <span class="operator">-F</span> <span class="string">'[ :]+'</span> <span class="string">'NR==2&#123;printf "%d", ($3)/$2*100&#125;'</span>`</span><br><span class="line"><span class="comment"># -e参数是使 "\n"换行符生效进行输出换行的</span></span><br><span class="line">echo <span class="literal">-e</span> <span class="variable">$mem_used_persent</span><span class="string">'%\n'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#统计磁盘使用情况，df -P参数可以防止打印输出的内容换行</span></span><br><span class="line">df <span class="literal">-THP</span> | awk <span class="operator">-F</span> <span class="string">'[ ]+'</span> <span class="string">'NR!=1&#123;print $1","$6&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p>12%<br>37%</p><p>/dev/mapper/vg_minghui-lv_root,25%<br>tmpfs,1%<br>/dev/sda1,10%<br>/dev/sr0,100%</p><p>前两行的内容：12% - cpu的使用率， 37% - 内存的使用率；</p><p>后面四行的内容：每个磁盘分区的使用率，磁盘分区名称和其使用率之间用英文逗号隔开。</p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo测试</title>
      <link href="/2020/01/19/HelloWorld/"/>
      <url>/2020/01/19/HelloWorld/</url>
      
        <content type="html"><![CDATA[<p>测试：Hello ，欢迎来到java的海洋。</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
