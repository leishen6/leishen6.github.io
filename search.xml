<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tomcat优化，值得你拥有！</title>
      <link href="/2020/08/24/tomcat_optimize/"/>
      <url>/2020/08/24/tomcat_optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Tomcat作为Web应用的服务器，目前绝大多数公司都是用其作为应用服务器的；应用服务器的执行效率会影响系统执行，这里会讲Tomcat怎样进行配置能提高处理性能；除此之外也必然会提到对应的JVM参数的优化的一些经验。</p></blockquote><p>本文为 <font color=#1AFA29> <strong>转载文章</strong> </font> ，原文地址：<a href="https://segmentfault.com/a/1190000015918707" target="_blank" rel="noopener">系统优化怎么做-Tomcat优化</a></p><h2 id="Tomcat的运行模式："><a href="#Tomcat的运行模式：" class="headerlink" title="Tomcat的运行模式："></a>Tomcat的运行模式：</h2><blockquote><p>运行模式分3种模式：</p><ul><li>bio：默认的模式，效率比较低</li><li>nio：优化时使用的模式</li><li>apr：对系统配置有一些比较高的要求</li></ul></blockquote><h2 id="确认Tomcat运行模式："><a href="#确认Tomcat运行模式：" class="headerlink" title="确认Tomcat运行模式："></a>确认Tomcat运行模式：</h2><blockquote><p>查找配置文件  <strong>server.xml</strong> ， 在tomcat下的路径：conf 目录下；</p><p>Executor 为自定义配置 Tomcat 线程池：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"1024"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">minSpareThreads</span>=<span class="string">"512"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关键配置："><a href="#关键配置：" class="headerlink" title="关键配置："></a>关键配置：</h3><h5 id="maxThreads："><a href="#maxThreads：" class="headerlink" title="maxThreads："></a>maxThreads：</h5><blockquote><p>最大线程数，默认是200</p></blockquote><h5 id="minSpareThread："><a href="#minSpareThread：" class="headerlink" title="minSpareThread："></a>minSpareThread：</h5><blockquote><p>最小活跃线程数，默认是25</p></blockquote><h5 id="maxQueueSize："><a href="#maxQueueSize：" class="headerlink" title="maxQueueSize："></a>maxQueueSize：</h5><blockquote><p>最大的等待队列个数，超过则请求拒绝默认值是Integer.MAX_VALUE ，一般不改变。在某些紧急状态修复问题需要调整</p></blockquote><h5 id="连接器（Connector）："><a href="#连接器（Connector）：" class="headerlink" title="连接器（Connector）："></a>连接器（Connector）：</h5><blockquote><p>Connector是连接器，负责接收客户的请求，以及向客户端回送响应的消息。所以Connector的优化是重要部分。默认情况下 Tomcat只支持200线程访问，超过这个数量的连接将被等待甚至超时放弃，所以我们需要提高这方面的处理能力。</p></blockquote><h3 id="nio-配置："><a href="#nio-配置：" class="headerlink" title="nio 配置："></a>nio 配置：</h3><blockquote><p>配置文件  <strong>server.xml</strong> </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 运行模式为 nio --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"14081"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line">&lt;!-- 连接器中连接处理 使用上面自定义的 线程池中的线程 --&gt;</span><br><span class="line">executor="tomcatThreadPool" </span><br><span class="line">URIEncoding="UTF-8" </span><br><span class="line">compression="on"   </span><br><span class="line">useBodyEncodingForURI="true" </span><br><span class="line">enableLookups="false" </span><br><span class="line">redirectPort="14443" /&gt;</span><br></pre></td></tr></table></figure><h3 id="影响性能的配置："><a href="#影响性能的配置：" class="headerlink" title="影响性能的配置："></a>影响性能的配置：</h3><h5 id="protocol："><a href="#protocol：" class="headerlink" title="protocol："></a>protocol：</h5><blockquote><p>org.apache.coyote.http11.Http11Protocol - 阻塞式的Java连接器<br>org.apache.coyote.http11.Http11NioProtocol - 不阻塞Java连接器<br>org.apache.coyote.http11.Http11AprProtocol - APR / native 连接器<br>选择不阻塞Java连接器</p></blockquote><h5 id="enableLookups："><a href="#enableLookups：" class="headerlink" title="enableLookups："></a>enableLookups：</h5><blockquote><p>若是你想request.getRemoteHost()的调用履行，以便返回的长途客户端的实际主机名的DNS查询，则设置为true。设置为false时跳过DNS查找，并返回字符串的IP地址（从而提高性能）。 <strong>默认场景下，禁用DNS查找</strong> 。</p></blockquote><h5 id="compression："><a href="#compression：" class="headerlink" title="compression："></a>compression：</h5><blockquote><p>设置成on，开启压缩</p></blockquote><h3 id="禁用AJP链接器"><a href="#禁用AJP链接器" class="headerlink" title="禁用AJP链接器:"></a>禁用AJP链接器:</h3><p>使用Nginx+tomcat的架构，用不着AJP协议，所以把AJP连接器禁用<br>server.xml注释掉以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8019"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="优化-JVM："><a href="#优化-JVM：" class="headerlink" title="优化 JVM："></a>优化 JVM：</h2><blockquote><p>优化位置：/bin/catalina.sh</p><p>修改 <strong>JAVA_OPTS</strong> 参数，这里需要参照 <strong>机器配置</strong> ，对JVM进行参数优化 。</p></blockquote><h5 id="JDK1-7："><a href="#JDK1-7：" class="headerlink" title="JDK1.7："></a>JDK1.7：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS="-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms512m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=1024M -XX:PermSize=1024m -XX:MaxPermSize=1024m -XX:+DisableExplicitGC"</span><br></pre></td></tr></table></figure><h5 id="JDK1-8："><a href="#JDK1-8：" class="headerlink" title="JDK1.8："></a>JDK1.8：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS="-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=1024M -XX:+DisableExplicitGC"</span><br></pre></td></tr></table></figure><p>注意：1.8 中已经没有 <strong>永久代</strong>了，所以也就没有 <strong>没有PermSize、MaxPermSize</strong>  ；Java8 中将永久代改为了 <strong>元空间</strong> 了，JAVA8里对metaspace可以在小范围自动扩展永生代避免溢出。</p><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul><li>-Djava.awt.headless</li></ul><blockquote><p>没有设备、键盘或鼠标的模式。</p></blockquote><ul><li>-Dfile.encoding</li></ul><blockquote><p>设置字符集</p></blockquote><ul><li>-server</li></ul><blockquote><p>jvm的server工作模式，对应的有client工作模式。使用“java -version”可以查看当前工作模式</p></blockquote><ul><li>-Xms1024m</li></ul><blockquote><p>初始Heap大小，使用的最小内存</p></blockquote><ul><li>-Xmx1024m</li></ul><blockquote><p>Java heap最大值，使用的最大内存<br>经验: 设置Xms大小等于Xmx大小</p></blockquote><ul><li>-XX:NewSize=512m</li></ul><blockquote><p>表示新生代初始内存的大小，应该小于 -Xms的值</p></blockquote><ul><li>-XX:MaxNewSize=1024M</li></ul><blockquote><p>表示新生代可被分配的内存的最大上限，应该小于 -Xmx的值</p></blockquote><ul><li>-XX:PermSize=1024m</li></ul><blockquote><p>设定内存的永久保存区域,内存的永久保存区域，VM 存放Class 和 Meta 信息，JVM在运行期间不会清除该区域； <strong>一般情况下，此参数值使用默认即可，默认大小就够用了</strong> 。</p><p>程序加载很多class情况下，超出PermSize情况下：<br>JDK1.7会抛出java.lang.OutOfMemoryError:  <strong>PermGen space异常</strong><br>JDK1.8下会抛出 ERROR: java.lang.OutOfMemoryError:  <strong>Metadata space 异常</strong> </p></blockquote><ul><li>-XX:MaxPermSize=1024m</li></ul><blockquote><p>设定最大内存的永久保存区域<br>经验: 设置PermSize大小等于MaxPermSize大小</p></blockquote><ul><li>-XX:+DisableExplicitGC</li></ul><blockquote><p>自动将System.gc()调用转换成一个空操作，即应用中调用System.gc()会变成一个空操作,避免程序员在代码里进行System.gc()这种危险操作。System.gc() 除非是到了万不得也的情况下使用，都交给JVM吧</p></blockquote><h3 id="其他参数优化："><a href="#其他参数优化：" class="headerlink" title="其他参数优化："></a>其他参数优化：</h3><ul><li>X:SurvivorRatio=2</li></ul><blockquote><p>年轻代中Eden区与Survivor区的大小比值</p></blockquote><ul><li>-XX:ReservedCodeCacheSize=256m</li></ul><blockquote><p>保留代码占用的内存容量，无大的影响</p></blockquote><ul><li>-Xss1024k</li></ul><blockquote><p>单个线程堆栈大小值，减少这个值可以生成更多线程，操作系统对于一个进程内的线程数是有限制的，经验值在3000-5000左右</p></blockquote><ul><li>-XX:+CMSParallelRemarkEnabled</li></ul><blockquote><p>CMS 垃圾回收算法，对响应时间的重要性需求 大于 对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用</p></blockquote><ul><li>-XX:+UseCMSCompactAtFullCollection</li></ul><blockquote><p>在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。</p></blockquote><ul><li>-XX:+UseCMSInitiatingOccupancyOnly</li></ul><blockquote><p>在FULL GC的时候， 对年老代的压缩。CMS是不会移动内存的， 因此这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片。</p></blockquote><ul><li>-XX:CMSInitiatingOccupancyFraction=60</li></ul><blockquote><p>使用cms作为垃圾回收, 使用60％后开始CMS收集</p></blockquote><ul><li>-XX:+UseGCOverheadLimit</li></ul><blockquote><p>用来限制使用内存，如果不做控制，可能会报出<br>java.lang.OutOfMemoryError: GC overhead limit exceeded</p></blockquote><ul><li>-XX:+UseConcMarkSweepGC</li></ul><blockquote><p>使用CMS内存收集</p></blockquote><ul><li>-XX:+UseParNewGC</li></ul><blockquote><p>设置年轻代为并行收集</p></blockquote><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li><li>-XX:HeapDumpPath=/x/dump_tomcat.hprof</li></ul><blockquote><p>JVM会在遇到OutOfMemoryError时拍摄一个“堆转储快照”，并将其保存在一个文件中。</p></blockquote><ul><li>-Xloggc:/xx/gc_tomcat.log</li></ul><blockquote><p>gc的日志，如果该日志中出现频繁的Full GC就是有相关的系统问题，如果很少，说明暂时还算正常</p></blockquote><ul><li>-XX:+PrintGCDateStamps</li></ul><blockquote><p>输出GC的时间戳（以基准时间的形式）</p></blockquote><ul><li>-XX:+PrintGCDetails</li></ul><blockquote><p>输出GC的日志格式</p></blockquote><ul><li>-Dnetworkaddress.cache.ttl=60</li><li>-Dsun.net.inetaddr.ttl=60</li></ul><blockquote><p>设置DNS缓存时间</p></blockquote><ul><li>-DautoStartup=false</li><li>-Dsun.net.client.defaultConnectTimeout=60000</li></ul><blockquote><p>连接建立超时时间</p></blockquote><ul><li>-Dsun.net.client.defaultReadTimeout=60000</li></ul><blockquote><p>内容获取超时设置</p></blockquote><ul><li>-Djmagick.systemclassloader=no</li></ul><blockquote><p>是否生成缩略图的一个框架的配置</p></blockquote><ul><li>-Djava.security.egd=file:/dev/./urandom</li></ul><h3 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_OPTS="-server -showversion -Xms2000m -Xmx2000m -Xmn500m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:SurvivorRatio=2 -XX:ReservedCodeCacheSize=256m -Xss1024k -Djava.awt.headless=true -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=60 -XX:+UseGCOverheadLimit -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tomcat_path/logs/dump_tomcat.hprof -Xloggc:/tomcat_path/logs/gc_tomcat.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCDetails -Dnetworkaddress.cache.ttl=60 -Dsun.net.inetaddr.ttl=60 -DautoStartup=false -Dsun.net.client.defaultConnectTimeout=60000 -Dsun.net.client.defaultReadTimeout=60000 -Djmagick.systemclassloader=no -Djava.security.egd=file:/dev/./urandom -Dfile.encoding=UTF-8"</span><br></pre></td></tr></table></figure><h3 id="常见-JVM-异常："><a href="#常见-JVM-异常：" class="headerlink" title="常见 JVM 异常："></a>常见 JVM 异常：</h3><ol><li><p>java.lang.OutOfMemoryError: Java heap space —-JVM Heap（堆）溢出：</p><blockquote><p>JVM 在启动的时候会自动设置 JVM Heap  的值，其初始空间（即-Xms）是物理内存的1/64，最大空间（-Xmx）不可超过物理内存。可以利用 JVM提供的 -Xmn -Xms -Xmx  等选项可进行设置。Heap 的大小是 Young Generation 和 Tenured Generaion 之和。在 JVM 中如果 98％ 的时间是用于 GC，且可用的 Heap size 不足 2％ 的时候将抛出此异常信息。</p><p>解决方法：</p><ul><li>首先检查代码，是否存在创建了大量无用对象，且其被引用着，无法被GC回收 的代码；</li><li>手动设置 JVM Heap（堆）的大小；</li></ul></blockquote></li></ol><ol start="2"><li><p>java.lang.OutOfMemoryError: PermGen space —- PermGen space溢出：</p><blockquote><p>jdk1.8 抛出 ERROR: java.lang.OutOfMemoryError: Metadata space 异常<br>PermGen space 的全称是 Permanent Generation space，是指内存的永久保存区域。为什么会内存溢出，这是由于这块内存主要是被 JVM 存放Class 和 Meta 信息的，Class 在被 Load 的时候被放入 PermGen space 区域，它和存放  Instance 的 Heap 区域不同，sun 的 GC 不会在主程序运行期对 PermGen space 进行清理，所以如果你的 APP  会载入很多 CLASS 的话，就很可能出现 PermGen space 溢出。</p><p>解决方法： 手动设置 MaxPermSize 大小；</p></blockquote></li></ol><ol start="3"><li>java.lang.StackOverflowError —- 栈溢出：</li></ol><blockquote><p>​      栈溢出了，JVM 依然是采用栈式的虚拟机。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的  “层”太多了，以致于把栈区溢出了。通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K  的空间（这个大约相当于在一个 C 函数内声明了 256 个 int 类型的变量），那么栈区也不过是需要 1MB 的空间。通常栈的大小是  1－2MB 的。</p><p>解决方法: 代码中递归也不要递归的层次过多；</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 系统优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合索引在B+树上的存储结构及数据查找方式</title>
      <link href="/2020/08/14/The_storage_structure_of_a_federated_index_on_a_tree/"/>
      <url>/2020/08/14/The_storage_structure_of_a_federated_index_on_a_tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最困难的事情就是认识自己！</p></blockquote><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>本篇文章主要是阐述下 <font color=blue>  <strong>联合索引</strong> </font> 在 B+Tree 上的实际存储结构。</p></blockquote><p><strong>本文主要讲解的内容有：</strong></p><ul><li><p>联合索引在B+树上的存储结构</p></li><li><p>联合索引的查找方式</p></li><li><p>为什么会有最左前缀匹配原则</p></li></ul><blockquote><p>在分享这篇文章之前，我在网上查了关于MySQL联合索引在B+树上的存储结构这个问题，翻阅了很多博客和技术文章，其中有几篇讲述的与事实相悖。具体如下：</p><p>很多博客中都是说：联合索引在B+树上的 <font color=blue> <strong>非叶子节点</strong> </font> 中只会存储 联合索引 中的第一个索引字段 的值，联合索引的其余索引字段的值只会出现在 B+树 的 <font color=blue> <strong>叶子节点</strong> </font> 中 。<font color=red>（其实这句话是不对的）</font></p></blockquote><p>如下图，就是 <strong>错误的</strong> 联合索引的 B+树 存储结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200813200952.png" alt=""></p><blockquote><p>庆幸的是通过不断查询发现有一条是来自思否社区的关于【联合索引 在 B+Tree 上的存储结构？】问答，有答主回答了这个问题，并贴出了一篇文章和一张图以及一句简单的描述。PS：贴出的文章链接已经打不开了。</p><p>所以在这样的条件下本篇文章就诞生了。</p></blockquote><h2 id="联合索引存储结构："><a href="#联合索引存储结构：" class="headerlink" title="联合索引存储结构："></a>联合索引存储结构：</h2><blockquote><p>下面就引用思否社区的这个问答来展开我们今天要讨论的联合索引的存储结构的问题。</p><p>来自思否的提问，联合索引的存储结构<br>(<a href="https://segmentfault.com/q/1010000017579884" target="_blank" rel="noopener">https://segmentfault.com/q/1010000017579884</a>)<br>有码友回答如下：</p><p><strong>联合索引 bcd , 在索引树中的样子如下图 ， 在比较的过程中 ，先判断 b 再判断 c 然后是 d ：</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200813201744.jpg" alt=""></p><p>由于回答只有这么一张图一句话，可能会让大家有点看不懂，所以我们就借助前人的肩膀用这个例子来更加细致的讲探寻一下联合索引在B+树上的存储结构吧。</p><p>首先，有一个T1表， 然后表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引idx_t1_bcd(b,c,d)，然后b、c、d三列作为联合索引，在B+树上的结构正如上图所示。联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。上图树高只有两层不容易理解，下面是假设的表数据以及我对其联合索引在B+树上的结构图的改进。 <strong>PS：基于InnoDB存储引擎。</strong></p><p>index（b、c、d）联合索引在B+树上的结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200813202442.jpg" alt=""></p><p>T1表中的数据如下图：（ <strong>上图 B+树 中的数据就来自下图</strong> ）</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200813202446.jpg" alt=""></p><blockquote><p>通过这俩图我们心里对联合索引在B+树上的存储结构就有了个大概的认识。下面用我的语言为大家解释一下吧。</p></blockquote><p>我们先看T1表，他的主键暂且我们将它设为整型自增的 ，InnoDB会使用主键索引在B+树维护索引和数据文件，然后我们创建了一个联合索引（b，c，d）也会生成一个索引树，同样是B+树的结构，只不过它的 <strong>data部分</strong> 存储的是联合索引所在行记录的主键值 <strong>（上图叶子节点紫色背景部分）</strong> 。为什么是 主键值，而不是 整个行记录呢？ 因为这个 联合索引 是个 <strong>非聚簇索引</strong> 。</p><p>好了大致情况都介绍完了。下面我们结合这俩图来解释一下。</p><p>对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，如，1 1 5 12 13…它是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的1 1 4 ，1 1 5以及13 12 4, 13 16 1, 13 16 5就可以说明这种情况。</p><h2 id="联合索引具体查找步骤："><a href="#联合索引具体查找步骤：" class="headerlink" title="联合索引具体查找步骤："></a>联合索引具体查找步骤：</h2><p>当我们的SQL语言可以应用到索引的时候，比如 select * from T1 where b = 12 and c = 14 and d = 3 ；也就是T1表中a列为4的这条记录。 </p><p>查找步骤具体如下：</p><ol><li>存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址（此处实际上是存在一个指针的，指向的是下一个节点的磁盘位置）。</li><li>进行一次磁盘IO，将此节点值加载后内存中，然后根据第一步一样进行判断，发现 数据都是匹配的，然后根据指针将此联合索引值所在的叶子节点也从磁盘中加载后内存，此时又发生了一次磁盘IO，最终根据叶子节点中索引值关联的 <strong>主键值</strong>  。</li><li>根据主键值  <strong>回表</strong> 去主键索引树（聚簇索引）中查询具体的行记录。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200813202449.jpg" alt=""></p><h2 id="联合索引的最左前缀原则："><a href="#联合索引的最左前缀原则：" class="headerlink" title="联合索引的最左前缀原则："></a>联合索引的最左前缀原则：</h2><blockquote><p>之所以会有最左前缀匹配原则和联合索引的索引构建方式及存储结构是有关系的。</p></blockquote><p>首先我们创建的idx_t1_bcd(b,c,d)索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。</p><p>我们看，联合索引是首先使用多列索引的第一列构建的索引树，用上面idx_t1_bcd(b,c,d)的例子就是优先使用b列构建，当b列值相等时再以c列排序，若c列的值也相等则以d列排序。我们可以取出索引树的叶子节点看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200813202455.jpg" alt=""></p><p>索引的第一列也就是b列可以说是从左到右单调递增的，但我们看c列和d列并没有这个特性，它们只能在b列值相等的情况下这个小范围内递增，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。<br>​<br>由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用缓存的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。</p><p>这就像我们的电话本一样，有名和姓以及电话，名和姓就是联合索引。在姓可以以姓的首字母排序，姓的首字母相同的情况下，再以名的首字母排序。</p><p><strong>如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">M</span><br><span class="line">    毛 不易   <span class="number">178</span>********</span><br><span class="line">    马 化腾   <span class="number">183</span>********</span><br><span class="line">    马 云     <span class="number">188</span>********</span><br><span class="line">Z</span><br><span class="line">    张 杰     <span class="number">189</span>********</span><br><span class="line">    张 靓颖   <span class="number">138</span>********</span><br><span class="line">    张 艺兴   <span class="number">176</span>********</span><br></pre></td></tr></table></figure><p>我们知道名和姓是很快就能够从姓的首字母索引定位到姓，然后定位到名，进而找到电话号码，因为所有的姓从上到下按照既定的规则（首字母排序）是有序的，而名是在姓的首字母一定的条件下也是按照名的首字母排序的，但是整体来看，所有的名放在一起是无序的，所以如果只知道名查找起来就比较慢，因为无法用已排好的结构快速查找。</p><p>到这里大家是否明白了为啥会有最左前缀匹配原则了吧。</p><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p>如下列举一些SQL的索引使用情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">where</span> b = <span class="number">12</span> <span class="keyword">and</span> c = <span class="number">14</span> <span class="keyword">and</span> d = <span class="number">3</span>;<span class="comment">-- 全值索引匹配 三列都用到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">where</span> b = <span class="number">12</span> <span class="keyword">and</span> c = <span class="number">14</span> <span class="keyword">and</span> e = <span class="string">'xml'</span>;<span class="comment">-- 应用到两列索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">where</span> b = <span class="number">12</span> <span class="keyword">and</span> e = <span class="string">'xml'</span>;<span class="comment">-- 应用到一列索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">where</span> b = <span class="number">12</span>  <span class="keyword">and</span> c &gt;= <span class="number">14</span> <span class="keyword">and</span> e = <span class="string">'xml'</span>;<span class="comment">-- 应用到一列索引及索引条件下推优化</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">where</span> b = <span class="number">12</span>  <span class="keyword">and</span> d = <span class="number">3</span>;<span class="comment">-- 应用到一列索引  因为不能跨列使用索引 没有c列 连不上</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">where</span> c = <span class="number">14</span>  <span class="keyword">and</span> d = <span class="number">3</span>;<span class="comment">-- 无法应用索引，违背最左匹配原则</span></span><br></pre></td></tr></table></figure><h2 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h2><p>到这里MySQL索引的联合索引的存储结构及查找方式就讲完了，本人能力有限，也是站着前人的肩膀上创作的此文，因为看到搜索引擎的搜索结果前几个技术文章中有存在讲述不清或讲述有误的地方，所以自己才总结出这篇文章分享给大家，如有不对的地方一定要指正哦，谢谢了。</p><p>这篇文章断断续续利用工作之余画图加写作用了两三天，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里高谈阔论实属惭愧。就当是我个人的一篇学习笔记了。</p><p>另外，MySQL索引及知识非常广泛，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联合索引 </tag>
            
            <tag> B+Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找一个字符串中最长不含重复字符的子字符串，计算该最长子字符串的长度</title>
      <link href="/2020/07/10/search_string_noRepeat_childStr_length/"/>
      <url>/2020/07/10/search_string_noRepeat_childStr_length/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>算法题：查找一个字符串中最长不含重复字符的子字符串，计算该最长子字符串的长度；</p><p>下面将使用 <strong>滑动窗口</strong> 方法实现，并通过对滑动窗口算法一步步进行优化，使其空间和时间的消耗一步步降低；</p></blockquote><h2 id="什么是滑动窗口？"><a href="#什么是滑动窗口？" class="headerlink" title="什么是滑动窗口？"></a>什么是滑动窗口？</h2><blockquote><p>滑动窗口：一般是指 <strong>运行在一个大数组上的子数组，该大数组是一个底层元素集合</strong> 。</p><p>例如：假设有大数组  <strong>[ a b c d b e f d n ]</strong>  ，设定一个大小为 3 的小数组 为 <strong>滑动窗口</strong> ；则存在下面的窗口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[a b c]</span><br><span class="line">  [b c d]</span><br><span class="line">    [c d b]</span><br><span class="line">      [d b e]</span><br><span class="line">        [b e f]</span><br><span class="line">          [e f d]</span><br><span class="line">    [f d n]</span><br></pre></td></tr></table></figure><blockquote><p>滑动窗口重要性质：</p><ol><li>滑动窗口一般表示成一个  <strong>左闭右开区间</strong>  。</li><li><strong>窗口的左边界（指针 i）和右边界（指针 j）永远只能向右移动</strong> ，而不能向左移动。</li></ol></blockquote><p><strong>如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200710164220.png" alt=""></p><h2 id="使用滑动窗口解题"><a href="#使用滑动窗口解题" class="headerlink" title="使用滑动窗口解题"></a>使用滑动窗口解题</h2><h4 id="1、未优化的滑动窗口实现："><a href="#1、未优化的滑动窗口实现：" class="headerlink" title="1、未优化的滑动窗口实现："></a>1、未优化的滑动窗口实现：</h4><blockquote><p>没有任何优化的滑动窗口实现；</p><p>通过 指针 i  和  指针 j  不断的向左移动，形成了一个个的窗口，并且在将窗口的字符存放到了  Set 集合中，使用 Set 集合判断 <strong>即将</strong> 进入窗口中的字符（也就是指针 j 移动到指向的字符）是否在窗口已经存在；</p><ol><li>如果已经存在：则计算此时窗口的大小，并将存放窗口字符的 Set 集合清空（清空是为了存放下个窗口的字符），最后将 指针 i 向左移动一位，然后指针 j 也指向指针 i 的位置。</li><li>如果是不存在：则将此字符存放到 Set 集合窗口字符中 。</li></ol></blockquote><h5 id="1-1、看图理解："><a href="#1-1、看图理解：" class="headerlink" title="1.1、看图理解："></a>1.1、看图理解：</h5><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200710142010.png" alt=""></p><h5 id="1-2、代码实现："><a href="#1-2、代码实现：" class="headerlink" title="1.2、代码实现："></a>1.2、代码实现：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class LeetCode &#123;</span><br><span class="line"></span><br><span class="line">    public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if (s &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.length() &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; set 用来存储窗口的字符</span><br><span class="line">        Set&lt;Character&gt; set &#x3D; new HashSet();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指针i</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 指针j</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        &#x2F;&#x2F; 最大长度</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        char[] sc &#x3D; s.toCharArray();</span><br><span class="line">        while(j &lt; sc.length &amp;&amp; i &lt;&#x3D; j)&#123;</span><br><span class="line">            &#x2F;&#x2F; 当字符没在窗口中</span><br><span class="line">            if (!set.contains(sc[j]))&#123;</span><br><span class="line">                set.add(sc[j]);</span><br><span class="line">                &#x2F;&#x2F; 指针j 移动</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果字符在窗口中时, 得到当前窗口中的字符个数</span><br><span class="line">                int size &#x3D; set.size();</span><br><span class="line">                if (max &lt; size)&#123;</span><br><span class="line">                    max &#x3D; size;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 将set中存储的字符清空</span><br><span class="line">                set.clear();</span><br><span class="line">                &#x2F;&#x2F; 指针i 移动</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F; 指针j 移动到指针i 的位置</span><br><span class="line">                j &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当指针j 移动到字符串尾部时, 窗口中可能还存在字符</span><br><span class="line">        if (set.size() &gt; max)&#123;</span><br><span class="line">            max &#x3D; set.size();</span><br><span class="line">            set.clear();</span><br><span class="line">            set &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(lengthOfLongestSubstring(&quot;abcdbefdn&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3、执行效果（来自LeetCode）："><a href="#1-3、执行效果（来自LeetCode）：" class="headerlink" title="1.3、执行效果（来自LeetCode）："></a>1.3、执行效果（来自LeetCode）：</h5><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200710174547.png" alt=""></p><h5 id="1-4、未经优化的滑动窗口的缺点："><a href="#1-4、未经优化的滑动窗口的缺点：" class="headerlink" title="1.4、未经优化的滑动窗口的缺点："></a>1.4、未经优化的滑动窗口的缺点：</h5><blockquote><p><strong>缺点一：</strong></p><p>存在很多无用的重复的  <strong>滑动窗口</strong> ；</p><p>例如：字符串 abcdbefdn，根据上面实现的滑动窗口方法，会得到以下窗口：[ a b c d ]、[ b c d ]、[ c d b e f ]、[ d b e f ]、[ b e f d n ]  这 5 个滑动窗口；下面错位展示更直观，会发现  <strong>[ b c d ]、 [ d b e f ]</strong>  这两个滑动窗口显然被包含在其之前的窗口中，它们被重复统计了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ a b c d ]</span><br><span class="line"></span><br><span class="line">  [ b c d ]</span><br><span class="line"></span><br><span class="line">    [ c d b e f ]</span><br><span class="line"></span><br><span class="line">      [ d b e f ]</span><br><span class="line"></span><br><span class="line">        [ b e f d n ]</span><br></pre></td></tr></table></figure><blockquote><p><strong>缺点二：</strong></p><p>存储 滑动窗口中 字符的 Set 集合存在反复 清空，再次存入字符的情况；并且存在字符被重复存入 Set 集合中。</p></blockquote><h4 id="2、优化后的滑动窗口实现："><a href="#2、优化后的滑动窗口实现：" class="headerlink" title="2、优化后的滑动窗口实现："></a>2、优化后的滑动窗口实现：</h4><blockquote><p>优化点：</p><ol><li><p>直接将指针 i  指向出现的重复字符的位置，滑动窗口大小为 （j - i），这样就将无用的重复的 <strong>滑动窗口</strong>  跳过，这样会大大缩短执行时间；</p></li><li><p>存放滑动窗口的字符容器改为 Map 集合，key为 字符，value 为字符下标；并且不再清空集合了，而是遇到重复字符后，更新此字符的下标位置；</p><p>例如：一开始 字符 b 在map集合中的value 位置为1，当再次遇到下标为 3 的字符 b 后，将map集合中的value 下标  <strong>由 1 改为 3</strong> ；</p></li></ol></blockquote><h5 id="2-1、看图理解："><a href="#2-1、看图理解：" class="headerlink" title="2.1、看图理解："></a>2.1、看图理解：</h5><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200710142023.png" alt=""></p><h5 id="2-2、代码实现："><a href="#2-2、代码实现：" class="headerlink" title="2.2、代码实现："></a>2.2、代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// map 用来存储窗口字符, key是字符, value为字符在字符串中的下标位置</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针j</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重复字符的位置, 默认为-1</span></span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(j &lt; sc.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sc[j]))&#123;</span><br><span class="line">                <span class="comment">// 获取map中重复字符的位置</span></span><br><span class="line">                <span class="keyword">int</span> index = map.get(sc[j]);</span><br><span class="line">                <span class="keyword">if</span> (index &gt; i)&#123;</span><br><span class="line">                    i = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指着j - 重复字符的位置 = 当前窗口的大小</span></span><br><span class="line">            <span class="keyword">if</span> ((j-i) &gt; max)&#123;</span><br><span class="line">                max = j-i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果map中存在重复字符的话,这里是将字符的位置进行更新 ; 如果不是重复字符的话，就直接存放到map中</span></span><br><span class="line">            map.put(sc[j], j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear();</span><br><span class="line">        map = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(lengthOfLongestSubstring(<span class="string">"abcdbefdn"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、执行效果（来自LeetCode）："><a href="#2-3、执行效果（来自LeetCode）：" class="headerlink" title="2.3、执行效果（来自LeetCode）："></a>2.3、执行效果（来自LeetCode）：</h5><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200710174556.png" alt=""></p><blockquote><p>上面就是经过了代码优化后得到的执行效果，发现执行时间大大缩短了；但是这可能还不是最优的，可能还存在最优的方法。</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA对使用了第三方依赖jar包的非Maven项目打jar包</title>
      <link href="/2020/07/03/IDEA_packaging/"/>
      <url>/2020/07/03/IDEA_packaging/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200703110935.jpg" alt=""></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>最近，遇到了一个问题，都快把我整疯了；</p><p>这个问题开始是由  <strong>使用IDEA 对 <font color=red>非Maven项目</font>进行打 Jar 包</strong> 引起的；</p><p>本来就是想简简单单的打个 jar 包，并将使用的第三方依赖 jar 包打进去，但是问题就出现在了项目中依赖的第三方 jar 包（ <strong>bcprov-jdk15on-1.54.jar</strong> ）存在签名，那在打包过程中会把 <strong>签名</strong> 破坏掉，导致在使用打好的jar包时报错：<font color=red>  *<em>JCE cannot authenticate the provider BC *</em> </font> 。</p><p>注意：如果依赖的第三方jar包不存在签名的话，直接按照下面的 打包方式 就能成功打包；</p></blockquote><h2 id="IDEA打jar包："><a href="#IDEA打jar包：" class="headerlink" title="IDEA打jar包："></a>IDEA打jar包：</h2><blockquote><p>使用 IDEA 将项目打成jar包，并将使用的第三方依赖jar包打进去；</p></blockquote><h4 id="1、首先看下打包的项目工程："><a href="#1、首先看下打包的项目工程：" class="headerlink" title="1、首先看下打包的项目工程："></a>1、首先看下打包的项目工程：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200703093412.png" alt=""></p><h4 id="2、具体的打包流程："><a href="#2、具体的打包流程：" class="headerlink" title="2、具体的打包流程："></a>2、具体的打包流程：</h4><h5 id="2-1、首先配置-MANIFEST-MF"><a href="#2-1、首先配置-MANIFEST-MF" class="headerlink" title="2.1、首先配置 MANIFEST.MF"></a>2.1、首先配置 MANIFEST.MF</h5><blockquote><p>首先需要配置 <strong>MANIFEST.MF</strong> ， 因为这会在打包时使用的； </p><p>首先新建一个文件夹，文件夹取名为 <strong>META-INF</strong> ， 在文件夹META-INF中创建文件，取名为 <strong>MANIFEST.MF</strong> ，然后需要配置下 MANIFEST.MF 文件的内容；  内容如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Class-Path: lib/log4j-core-<span class="number">2.0</span>-rc1.jar lib/bcprov-jdk15on-<span class="number">1.54</span>.jar </span><br><span class="line">Main-Class: com.lyl.Test.PackageTest</span><br></pre></td></tr></table></figure><blockquote><p>注意上面 <strong>MANIFEST.MF</strong> 配置文件中的内容在填写时，需要注意几点：</p><p>1、Class-Path 在 冒号后面需要有 <strong>一个空格</strong> ；然后后面跟随的每个依赖包之间也必须有 <strong>一个空格</strong> ，并且最后一个依赖后面也必须要存在 <strong>一个空格</strong> ；</p><p>2、Main-Class这一行后面需要跟 <strong>两个空行</strong>　；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200703093408.png" alt=""></p><blockquote><p>最后简单说下，MANIFEST.MF 在打包时起到什么作用呢：</p><ol><li><p>Main-Class 指定程序的运行入口，这样可以直接用java  -jar  xxx.jar来运行程序。</p></li><li><p>Class-Path 指定依赖jar包的路径，class loader类加载器会依据这个路径来搜索依赖的class。</p></li></ol></blockquote><h5 id="2-2、具体配置过程"><a href="#2-2、具体配置过程" class="headerlink" title="2.2、具体配置过程"></a>2.2、具体配置过程</h5><blockquote><p>下面将进行打包前的一些配置，需要将这些配置好后，才能进行打包的；</p></blockquote><p>（1）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702185225.png" alt=""></p><p>（2）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702185228.png" alt=""></p><p>（3）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702185557.png" alt=""></p><p>（4）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702185916.png" alt=""></p><p>（5）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702185920.png" alt=""></p><p>（6）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702192121.png" alt=""></p><p>（7）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702190003.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200703093757.png" alt=""></p><p>（8）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702190007.png" alt=""></p><h5 id="2-3、进行打包"><a href="#2-3、进行打包" class="headerlink" title="2.3、进行打包"></a>2.3、进行打包</h5><blockquote><p>上面将打包前的一些配置完成后，最后就可以直接进行打包了；</p></blockquote><p>（1）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702190010.png" alt=""></p><p>（2）、</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702190013.png" alt=""></p><blockquote><p>end， IDEA 打jar包流程已经完成了；但是打好的jar包，直接使用时，可能还会存在问题，再聊聊会出现的问题。</p><p>扩展： 如果想在打jar包时，将依赖的第三包jar包打进去的话，使用IDEA可能会比较繁琐，但是使用 Eclipse 会比较方便快捷，直接使用 Eclipse 的  <strong>fat jar 插件</strong> 进行打包，十分方便的。</p></blockquote><h2 id="3、打好的jar包在使用时可能存在的问题："><a href="#3、打好的jar包在使用时可能存在的问题：" class="headerlink" title="3、打好的jar包在使用时可能存在的问题："></a>3、打好的jar包在使用时可能存在的问题：</h2><h4 id="3-1、报错：Invalid-signature-file-digest-for-Manifest-main-attributes"><a href="#3-1、报错：Invalid-signature-file-digest-for-Manifest-main-attributes" class="headerlink" title="3.1、报错：Invalid signature file digest for Manifest main attributes"></a>3.1、报错：Invalid signature file digest for Manifest main attributes</h4><blockquote><p>将打好的jar包引用到另一个项目中，可能会报错：Invalid signature file digest for Manifest main attributes ；</p><p>这就是因为 打好的jar包中 存在多余的.SF文件，可以将jar包中后缀为 .SF文件删除就可以了。</p></blockquote><h4 id="3-2、报错：JCE-cannot-authenticate-the-provider-BC"><a href="#3-2、报错：JCE-cannot-authenticate-the-provider-BC" class="headerlink" title="3.2、报错：JCE cannot authenticate the provider BC"></a>3.2、报错：JCE cannot authenticate the provider BC</h4><blockquote><p>在项目中使用打好的jar包，可能会报错：JCE cannot authenticate the provider BC ；</p><p>这是因为 之前打包时，项目中依赖的第三方jar包中有存在 <strong>签名</strong> 的jar包（<strong>bcprov-jdk15on-1.54.jar</strong>）；在将其打进jar包时，就会将签名破坏掉，导致在使用这个签名被破坏的包中的类时，就会报错了。</p></blockquote><h4 id="3-3、解决方案："><a href="#3-3、解决方案：" class="headerlink" title="3.3、解决方案："></a>3.3、解决方案：</h4><h5 id="3-3-1、将签名包放一份到本地JDK中（不推荐）"><a href="#3-3-1、将签名包放一份到本地JDK中（不推荐）" class="headerlink" title="3.3.1、将签名包放一份到本地JDK中（不推荐）"></a>3.3.1、将签名包放一份到本地JDK中（不推荐）</h5><blockquote><p>此方案需要将签名包（<strong>bcprov-jdk15on-1.54.jar</strong>）放到 JDK 中的 jre 中的lib文件夹下的 ext 文件夹中；</p><p>例如：本地安装的JDK路径为  E:\Java\jdk1.8.0_60\jre\lib\ext ;  将签名包放到这里一份 。</p><p>但是此解决方案不推荐，为什么不推荐呢？</p><p>因为如果你打的jar包需要提供给别人的话，别人为了使用你的jar包，还需要改变自己的JDK，这个不太方便了。</p></blockquote><h5 id="3-3-2、打包时，不讲依赖签名包打进去（推荐）"><a href="#3-3-2、打包时，不讲依赖签名包打进去（推荐）" class="headerlink" title="3.3.2、打包时，不讲依赖签名包打进去（推荐）"></a>3.3.2、打包时，不讲依赖签名包打进去（推荐）</h5><blockquote><p> 打包时，不将签名包打进去。打好包后，在项目中使用时，需要将依赖的签名包与打好的包一起放到 <strong>lib</strong> 文件夹下，这样在使用签名包时，就会使用与 打好的包在同级别下的 依赖的签名包。</p><p>使用这种方案进行解决时，会比第一种方案方便很多，只是使用时，除了引入打好的jar包外，还需哟再引入下使用到的签名包（ <strong>bcprov-jdk15on-1.54.jar</strong> ），并将其放到同一级别目录下 即可。</p></blockquote><p><strong>打包时，不将签名包打进去的实现步骤：</strong>（以 bcprov-jdk15on-1.54.jar 签名包为例子）</p><p>（1）、首先是将  <strong>MANIFEST.MF</strong> 配置文件进行修改：</p><p>之前：存在签名包的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Class-Path: lib/log4j-core-<span class="number">2.0</span>-rc1.jar lib/bcprov-jdk15on-<span class="number">1.54</span>.jar </span><br><span class="line">Main-Class: com.lyl.Test.PackageTest</span><br></pre></td></tr></table></figure><p>修改：就是将签名包 <strong>bcprov-jdk15on-1.54.jar</strong> 的依赖引入删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Class-Path: lib/log4j-core-<span class="number">2.0</span>-rc1.jar</span><br><span class="line">Main-Class: com.lyl.Test.PackageTest</span><br></pre></td></tr></table></figure><p>（2）、改完 配置文件后，再修改上面打包 <strong>具体配置步骤</strong> 中的  <strong>第（7）</strong> 中的引入依赖jar包，将签名包删除，然后再点击OK，并重新打包 即可。如下图：</p><p>之前，签名包也引入了：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200703093757.png" alt=""></p><p>之后，去掉引入的签名包：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200703094310.png" alt=""></p><p><strong>重新打好的包，由于没有将依赖的签名包打进去，那么如果使用到签名包bcprov-jdk15on-1.54.jar的类时，就会报《 <em>类找不到</em>  》怎么办呢？</strong></p><p>可以将打好的jar包 “  <strong>packagetest-1.0.0.jar</strong>  ”， 与 签名包  <strong>bcprov-jdk15on-1.54.jar</strong>   放到引用的项目的 <strong>lib</strong> 文件夹下（需要保证这两个jar包在项目中的存放的位置在同一级别 即可）； 然后在使用时就会使用 外部引用的 依赖签名包中的类了，不会报 <strong>类找不到</strong> 。 </p><p>并且没有破坏签名包的签名，所以也不会报签名被破坏的错了：JCE cannot authenticate the provider BC</p><blockquote><p>end， 暂时只找到了这两种解决方案，感觉这都不是最优的解决方案，但是实在找不到了，唉，如果有知道的朋友，可以告诉下吗？ 谢谢啦！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200702201319.gif" alt=""></p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑啦，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot结合Sharding-JDBC实现分库分表</title>
      <link href="/2020/06/20/SpringBoot_shardDB_shardTable/"/>
      <url>/2020/06/20/SpringBoot_shardDB_shardTable/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>今天来聊下 SpringBoot 集成 <strong>Sharding-JDBC</strong> 实现分库分表；为此写了一个小<strong><em>Demo</em></strong>，这个Demo是基于SpringBoot，并集成了  <strong>Mybatis、Redis、Swagger（生成在线的接口文档 ）、PageHelper（分页工具）</strong> 等，当然绝对也集成了 Sharding-JDBC ；以及设计了 <strong>RestFul</strong> 风格的接口 ，添加了 <strong>单元测试</strong> 。</p><p>下面简单介绍下本文的主线：</p><p>①、首先介绍下Demo的工程目录，并且介绍下使用的基本环境，如：sql、工程的pom.xml等</p><p>②、然后会着重介绍 SpringBoot 集成  Sharding-JDBC 的过程，及 Sharding-JDBC 基本知识 和 注意事项。</p></blockquote><h4 id="1、项目信息描述："><a href="#1、项目信息描述：" class="headerlink" title="1、项目信息描述："></a>1、项目信息描述：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620160051.png" alt=""></p><blockquote><p><font color=red> <strong>完整项目在gitHub，地址：</strong> </font> <a href="https://github.com/leishen6/SpringBoot_shardDB_shardTable" target="_blank" rel="noopener">https://github.com/leishen6/SpringBoot_shardDB_shardTable</a></p><p><strong>如有需要请自己去 giHub 上拉取代码进行查阅，由于本人水品有限，如有问题请留言提出，谢谢！</strong></p></blockquote><h2 id="Demo详解："><a href="#Demo详解：" class="headerlink" title="Demo详解："></a>Demo详解：</h2><h4 id="1、工程目录："><a href="#1、工程目录：" class="headerlink" title="1、工程目录："></a>1、工程目录：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620144919.png" alt=""></p><h4 id="2、工程环境："><a href="#2、工程环境：" class="headerlink" title="2、工程环境："></a>2、工程环境：</h4><h5 id="2-1、pom-xml"><a href="#2-1、pom-xml" class="headerlink" title="2.1、pom.xml :"></a>2.1、pom.xml :</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">     &lt;relativePath/&gt;</span><br><span class="line"> &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;properties&gt;</span><br><span class="line">     &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">     &lt;java.version&gt;1.7&lt;/java.version&gt;</span><br><span class="line"></span><br><span class="line">     &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt;</span><br><span class="line">     &lt;mysql-connector&gt;5.1.39&lt;/mysql-connector&gt;</span><br><span class="line">     &lt;fastjson&gt;1.2.41&lt;/fastjson&gt;</span><br><span class="line"> &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">         &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">         &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;!-- Spring Boot Mybatis 依赖 --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.0.1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- MySQL 连接驱动依赖 --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--druid 连接池--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;$&#123;fastjson&#125;&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--swagger--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- pagehelper分页工具 --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;4.1.6&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- sharding-jdbc --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;4.0.0-RC1&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- hutool 工具类 --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;hutool-setting&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;5.2.4&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：pom.xml 的内容最好不要改动了，因为如果将里面的一些 <strong>依赖版本变动了</strong> ，可能会导致依赖版本兼容性问题出现，最终导致程序运行失败。</p></blockquote><h5 id="2-2、sql-环境："><a href="#2-2、sql-环境：" class="headerlink" title="2.2、sql 环境："></a>2.2、sql 环境：</h5><p>①、数据库使用的 Mysql，Demo程序运行前需要提前创建好数据库，由于使用了分库分表，所以需要创建两个库； 数据库名：<strong>springboot0、springboot1</strong> 。</p><p>②、在 springboot0 数据库中执行下面的sql语句创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_role`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`role_name`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_user0</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_user0`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user0`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">65</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">43</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_user1</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_user1`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">65</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">35</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_user2</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_user2`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">65</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">34</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>③、然后在创建的 springboot1 数据库中执行sql语句创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_user0`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user0`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">65</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">36</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_user1</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_user1`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">65</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">34</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_user2</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t_user2`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">65</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">36</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><blockquote><p>上面的基本信息介绍完了，接下来介绍重头戏了，<strong><em>Sharding-JDBC 集成之路</em></strong>。嘿嘿 . . . . . </p></blockquote><h2 id="Sharding-JDBC-基本知识："><a href="#Sharding-JDBC-基本知识：" class="headerlink" title="Sharding-JDBC 基本知识："></a>Sharding-JDBC 基本知识：</h2><blockquote><p>首先将 Sharding-JDBC 的官网贴出来，也可以去官网进行详细了解。<a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/overview/" target="_blank" rel="noopener">shardingsphere 之 Sharding-JDBC</a>  </p><p>大家如果没去官网了解过的，也可以通过下面进行了解下哟：</p></blockquote><h4 id="1、基本概念："><a href="#1、基本概念：" class="headerlink" title="1、基本概念："></a>1、基本概念：</h4><p>Sharding-JDBC 定位为轻量级Java框架，在Java的<strong>JDBC层</strong>提供的额外服务，所以说它是一款属于 <strong><em>应用层依赖类中间件</em></strong> 。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><blockquote><p>应用层依赖类中间件：这类分库分表中间件的特点就是<strong>和应用强耦合</strong>，需要应用显示依赖相应的jar包。</p></blockquote><h4 id="2、兼容性："><a href="#2、兼容性：" class="headerlink" title="2、兼容性："></a>2、兼容性：</h4><ul><li>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li><li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</li><li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。</li></ul><h4 id="3、架构图："><a href="#3、架构图：" class="headerlink" title="3、架构图："></a>3、架构图：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620161834.png" alt=""></p><p>​                                                        图片来源：<a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/overview/" target="_blank" rel="noopener">sharding-JDBC官网</a></p><h4 id="4、数据分片："><a href="#4、数据分片：" class="headerlink" title="4、数据分片："></a>4、数据分片：</h4><blockquote><p>进行分库分表时，是绕不开 <strong>数据分片</strong> 的知识的。</p><p>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。</p><p>数据分片的拆分方式又分为<strong>垂直分片</strong>和<strong>水平分片（最为常用的方式）</strong>。</p></blockquote><h5 id="4-1、垂直分片："><a href="#4-1、垂直分片：" class="headerlink" title="4.1、垂直分片："></a>4.1、垂直分片：</h5><p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。</p><p>例如：本来一个库由订单表和用户表构成，由于并发量和数据量太大，可以将这原本的一个库进行拆分，拆分成两个库，一个订单库，里面只有一个订单表，一个用户库，里面只有一个用户表，这样使用两个库就能支持更大的并发量，提升数据库的并发瓶颈。</p><p><strong>缺点：</strong></p><p>垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。 垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。</p><h5 id="4-2、水平分片："><a href="#4-2、水平分片：" class="headerlink" title="4.2、水平分片："></a>4.2、水平分片：</h5><p>水平分片又称为横向拆分。 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。</p><p>注意：<strong>水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。</strong></p><blockquote><p>例如，本文中实现的分库分表就是使用的 <strong>水平分片</strong> ;  根据用户表中 <strong>name</strong> 用户名字段进行分片；</p><p>在新增用户数据时，首先根据配置的分片策略（分片策略包含分片算法）判断此用户名的数据到底新增到哪个数据库中，以及哪个表中。</p></blockquote><h4 id="5、内部执行流程："><a href="#5、内部执行流程：" class="headerlink" title="5、内部执行流程："></a>5、内部执行流程：</h4><blockquote><p> 核心由 <strong>SQL解析 =&gt; 执行器优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt; 结果归并</strong> 的流程组成。</p><p>主要介绍下 SQL路由、SQL改写的概念：</p><p>SQL路由：根据解析上下文匹配用户配置的分片策略，并生成最终的路由路径；</p><p>SQL改写：将SQL改写为在<strong>真实数据库</strong>中可以正确执行的语句。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620162548.png" alt=""></p><h2 id="Sharding-JDBC-集成过程："><a href="#Sharding-JDBC-集成过程：" class="headerlink" title="Sharding-JDBC 集成过程："></a>Sharding-JDBC 集成过程：</h2><h4 id="1、首先看下-Sharding-JDBC-的配置文件："><a href="#1、首先看下-Sharding-JDBC-的配置文件：" class="headerlink" title="1、首先看下 Sharding-JDBC 的配置文件："></a>1、首先看下 Sharding-JDBC 的配置文件：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620171454.png" alt=""></p><blockquote><p>下面是Sharding-JDBC 配置文件的内容；</p><p>注意：</p><p>本工程中的分库分表是分库2个，分表3个，分片键是  name 字段，分库分表都是依据name这个分片键，</p><p>分表只有 t_user 表进行分表；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分库分表 配置: (下面配置的分库数量、虚拟节点数量等主要是为了实现一致性hash算法进行分片)</span><br><span class="line"></span><br><span class="line"># 分库数量</span><br><span class="line">sharding.datasource.count=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 分库虚拟节点数量</span><br><span class="line">sharding.datasource.virtual.node.count=<span class="number">360</span></span><br><span class="line"></span><br><span class="line"># 虚拟节点映射到物理节点范围：例如本文中是根据name名字进行分片的, 所以使用名字的hash值对虚拟节点数取余;</span><br><span class="line"># 得到一个0-359的余数，然后按照余数所属的范围, 如果余数在0-179范围则数据分片访问 springboot0 数据源,</span><br><span class="line"># 如果余数在180-359范围，则数据被分片访问 springboot1 数据源; 下面的分表原理一样。</span><br><span class="line">sharding.datasource.virtual.node.count.rang=<span class="number">0</span>-<span class="number">179</span>,<span class="number">180</span>-<span class="number">359</span></span><br><span class="line"></span><br><span class="line"># 分表数量</span><br><span class="line">sharding.table.count=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 分表虚拟节点数量</span><br><span class="line">sharding.table.virtual.node.count=<span class="number">360</span></span><br><span class="line"></span><br><span class="line"># 虚拟节点映射到物理节点范围</span><br><span class="line">sharding.table.virtual.node.count.rang=<span class="number">0</span>-<span class="number">119</span>,<span class="number">120</span>-<span class="number">249</span>,<span class="number">250</span>-<span class="number">359</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实际数据源名字</span><br><span class="line">spring.shardingsphere.datasource.names=springboot0,springboot1</span><br><span class="line"></span><br><span class="line"># 数据源</span><br><span class="line">spring.shardingsphere.datasource.springboot0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.springboot0.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.springboot0.url=jdbc:mysql:<span class="comment">//localhost:3306/springboot0?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">spring.shardingsphere.datasource.springboot0.username=root</span><br><span class="line">spring.shardingsphere.datasource.springboot0.password=root</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.springboot1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.springboot1.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.springboot1.url=jdbc:mysql:<span class="comment">//localhost:3306/springboot1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">spring.shardingsphere.datasource.springboot1.username=root</span><br><span class="line">spring.shardingsphere.datasource.springboot1.password=root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 分片策略使用的是: 自定义的分片算法</span><br><span class="line">## 实际的数据节点，符合 groovy 语法; 这里的&#123;0..1&#125;指的是0到1及其之间的数字，数字有0，1两个，代表分库是两个;</span><br><span class="line">## 并且拼接在 springboot 后面，就构成了上面配置的实际数据源名称了</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.actualDataNodes=springboot$-&gt;&#123;<span class="number">0</span>..<span class="number">1</span>&#125;.t_user$-&gt;&#123;<span class="number">0</span>..<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">## 分片键：name字段</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.databaseStrategy.standard.shardingColumn=name</span><br><span class="line">## 自定义 分库 算法</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.databaseStrategy.standard.preciseAlgorithmClassName=com.lyl.algorithm.MyPreciseDBShardingAlgorithm</span><br><span class="line"></span><br><span class="line">## 分片键：name字段</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.tableStrategy.standard.shardingColumn=name</span><br><span class="line">## 自定义 分表 算法</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.tableStrategy.standard.preciseAlgorithmClassName=com.lyl.algorithm.MyPreciseTableShardingAlgorithm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 不进行分库分表的数据源指定，使用设置的默认数据源springboot0 ;例如，本文中的 t_role表就不进行</span><br><span class="line"># 分库分表，那关于 t_role 表的增删改差都走默认数据源 springboot0</span><br><span class="line">spring.shardingsphere.sharding.<span class="keyword">default</span>-data-source-name=springboot0</span><br><span class="line"># 打印执行的数据库以及语句</span><br><span class="line">spring.shardingsphere.props.sql.show=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><blockquote><p>如果需要更改分库数量，或者分表数量的话，那么也需要对配置文件进行更改；例如：将分库数量改为3个；</p><p>下面这些配置文件内容需要更改：</p><p>原配置内容：</p><p>sharding.datasource.count=2</p><p>sharding.datasource.virtual.node.count.rang=0-179,180-359</p><p>spring.shardingsphere.sharding.tables.t_user.actualDataNodes=springboot$-&gt;{0..1}.t_user$-&gt;{0..2}</p><p>改为：</p><p>sharding.datasource.count=3</p><p>sharding.datasource.virtual.node.count.rang=0-119,120-249,250-359</p><p>spring.shardingsphere.sharding.tables.t_user.actualDataNodes=springboot$-&gt;{0..2}.t_user$-&gt;{0..2}</p></blockquote><h4 id="2、一致性hash算法："><a href="#2、一致性hash算法：" class="headerlink" title="2、一致性hash算法："></a>2、一致性hash算法：</h4><p>一致性hash算法学习可参考：<a href="http://www.zsythink.net/archives/1182" target="_blank" rel="noopener">白话解析：一致性哈希算法 consistent hashing</a></p><blockquote><p>首先解释下，sharing-JDBC配置文件中使用的虚拟节点就是为了实现一致性hash算法；</p><p>为什么使用一致性hash算法呢？</p><p>因为，使用一致性hash算法是为了满足后期可能出现的数据库扩容问题；</p><p>在这里来简单介绍下，常用的分片算法（方式）：hash方式，<strong>一致性hash</strong>（consistent hash），按照数据范围（range based）。</p></blockquote><p>上面三种分片方式学习可参考：<a href="https://www.cnblogs.com/xybaby/p/7076731.html#_label_0" target="_blank" rel="noopener">带着问题学习分布式系统之数据分片</a></p><h5 id="2-1、介绍一致性hash算法为什么易于扩容呢？"><a href="#2-1、介绍一致性hash算法为什么易于扩容呢？" class="headerlink" title="2.1、介绍一致性hash算法为什么易于扩容呢？"></a>2.1、介绍一致性hash算法为什么易于扩容呢？</h5><p>结合下文本，本文是根据name字段进行分片的，使用name用户名的hash值对虚拟节点数360<strong>取余</strong> ，得到一个 </p><p>0-359 的余数，然后根据余数匹配配置的虚拟节点范围进行映射实际物理节点，来得到实际的数据源节点等。</p><p>如图：</p><blockquote><p>分库 2个，实际数据源 springboot0、springboot1，虚拟节点数360，虚拟节点范围 0-179，180-359</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620175720.png" alt=""></p><p><strong>进行扩容：</strong>（增加一个数据库）</p><blockquote><p>分库 3个，实际数据源 springboot0、springboot1、springboot2，虚拟节点数360不变，虚拟节点范围</p><p>0-179,180-269,270-359</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620181924.png" alt=""></p><p>如图，使用一致性hash算法，在扩容时，不会导致整体数据的不可用，只会损失一部分数据；原本分2个库时，应处于springboot1数据源中的数据，在分库3时，进行查询此数据时，会被分片到springboot2中查询，此时会出现查询不到的情况；但是，这也只是损失了一小部分数据，不会导致整体数据出现问题。</p><h4 id="3、自定义分片算法："><a href="#3、自定义分片算法：" class="headerlink" title="3、自定义分片算法："></a>3、自定义分片算法：</h4><h5 id="3-1、自定义分库实现："><a href="#3-1、自定义分库实现：" class="headerlink" title="3.1、自定义分库实现："></a>3.1、自定义分库实现：</h5><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620194412.png" alt=""></p><h5 id="3-2、自定义分表算法："><a href="#3-2、自定义分表算法：" class="headerlink" title="3.2、自定义分表算法："></a>3.2、自定义分表算法：</h5><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200620194419.png" alt=""></p><blockquote><p>end，本文结束 . . . . . . . . . . . . . . . . </p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分库分表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sharding-JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转链表？面试官你确定要让手写这个吗？</title>
      <link href="/2020/06/07/rotate_Single_linked_list/"/>
      <url>/2020/06/07/rotate_Single_linked_list/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>今天练习了一道关于单链表的算法题 <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">《旋转链表》</a>，由于之前写过一篇 <a href="https://segmentfault.com/a/1190000022791475" target="_blank" rel="noopener">《单链表反转？面试官你确定要问这个吗？》</a> 的文章，然后今天又碰到了这道有关单链表的算法，就想着再 <strong>“水篇文章”</strong> 吧（带引号的哈），可以证明我没偷懒，按时<strong>写作业</strong>了。<font color=red>嘿嘿 . . . . . . . . . </font></p><p>接下来，①、首先回忆下单链表的数据结构 ；②、详解描述下什么是旋转链表； ③、图解旋转链表代码</p></blockquote><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530152024.gif" style="zoom:50%;" /><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><h4 id="1-单链表的数据结构："><a href="#1-单链表的数据结构：" class="headerlink" title="1. 单链表的数据结构："></a>1. 单链表的数据结构：</h4><blockquote><p>单链表是一种线性结构，它是由一个个<font color=red><strong>节点（Node）</strong>组成的</font>。并且每个节点（Node）是由一块<font color=red><strong>数据域（data）</strong></font>和一块<font color=red><strong>指针域（next）</strong></font>组成的。 &nbsp;&nbsp;&nbsp;&nbsp; </p></blockquote><p>①、节点（Node）结构图如下：</p><blockquote><ol><li><strong>节点的数据域</strong>：data数据域一般就是用来存放数据的 。（注：data域需要指定类型，只能存放指定类型的数据，不能什么东西都放，是不是呀； 那代码中是怎么实现的呢？ 使用 <strong>泛型</strong>  。）</li><li><strong>节点的指针域</strong>：next指针域一般就是存放的指向下一个节点的指针；这个指针其实是一个内存地址，因为Node节点对象是存放在JVM中的堆内存中，所以节点的next指针域中存放就是下一个节点在堆内存中的地址；而在代码中对象的内存地址是赋值给其引用变量了，所以<strong>指针域中存放的是下一个节点对象的引用变量</strong>。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200607180119.png" alt=""></p><p>②、单链表结构图如下：（<strong>下图是由三个节点构成的单链表</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530154552.png" alt=""></p><blockquote><p>若有所思，en en en . . .  . . .   好像单链表的知识在脑海中清晰了些呀；那要不我们快马加鞭，赶紧把单链表的数据结构代码弄出来，然后再思索下怎么<strong>实现旋转操作</strong>， en en en. . . .. . .     嘿嘿！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530161055.gif" alt=""></p><h4 id="2-节点类Node代码："><a href="#2-节点类Node代码：" class="headerlink" title="2. 节点类Node代码："></a>2. 节点类Node代码：</h4><blockquote><p>创建Node节点类，节点类中并且额外提供了两个方法（单链表的创建方法、单链表的遍历方法）；</p><p>注意：单链表的创建方法 createLinkedList( )：Node节点的插入方式为 <font color=red><strong>尾插法</strong></font> ， 其实还有 <strong>头插法</strong> 方式；</p><p>扩展：链表中节点的插入方式还在 <strong>HashMap</strong> 中使用到了，<strong>在 JDK 1.7 时是头插法，JDK 1.8时是尾插法</strong>；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.linklist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  单链表的 节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-06-07 15:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的数据域</span></span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="comment">// 节点的指针域</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据域值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 单链表 （尾插法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 头节点</span></span><br><span class="line">        Node&lt;String&gt; head;</span><br><span class="line"></span><br><span class="line">        Node&lt;String&gt; n = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"111"</span>);</span><br><span class="line">        Node&lt;String&gt; n1 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"222"</span>);</span><br><span class="line">        Node&lt;String&gt; n2 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"333"</span>);</span><br><span class="line">        Node&lt;String&gt; n3 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"444"</span>);</span><br><span class="line">        Node&lt;String&gt; n4 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"555"</span>);</span><br><span class="line">        Node&lt;String&gt; n5 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"666"</span>);</span><br><span class="line">        <span class="comment">// 指定头节点</span></span><br><span class="line">        head = n;</span><br><span class="line">        n.next = n1;</span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        <span class="comment">// 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历单链表并在控制台打印输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  单链表的 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.data + <span class="string">" --&gt; "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"null"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote><p>给定一个链表，旋转链表，将链表每个节点<strong>向右移动 <em>k</em> 个位置</strong>，其中 <em>k</em> 是非负数。</p><p>自我理解：其实是将从尾部数的 <em>k</em> 个节点截取出来再拼接到 <em>head</em> 头节点上。</p><p><font color=red>注意：旋转链表操作会存在两种情况的，正如下面的 <strong>实例1 和 实例2</strong> 。</font></p></blockquote><h4 id="实例1：（移动位置-k-小于-单链表的长度）"><a href="#实例1：（移动位置-k-小于-单链表的长度）" class="headerlink" title="实例1：（移动位置 k 小于 单链表的长度）"></a>实例1：（移动位置 <em>k</em> 小于 单链表的长度）</h4><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL ,   <strong>k = 2 （每个节点向右移动2个位置）</strong><br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p></blockquote><p><strong>如图：（直接将 4 、5节点截取下来拼接到头结点上）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200607181504.png" alt=""></p><h4 id="实例2：（移动位置-k-大于-单链表的长度）"><a href="#实例2：（移动位置-k-大于-单链表的长度）" class="headerlink" title="实例2：（移动位置 k 大于 单链表的长度）"></a>实例2：（移动位置 <em>k</em> 大于 单链表的长度）</h4><blockquote><p>输入: 0-&gt;1-&gt;2-&gt;NULL ,    <strong>k = 4 （每个节点向右移动4个位置）</strong><br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p></blockquote><p><strong>如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200607182617.png" alt=""></p><h2 id="图解代码："><a href="#图解代码：" class="headerlink" title="图解代码："></a>图解代码：</h2><blockquote><p>旋转链表使用的方法是<strong>双指针法</strong>，会存在两个指针：<strong>current 指针、previous 指针</strong> 。通过两个指针移动，并且保证两个指针之间的间距为<strong>需要移动的位置数</strong> 。</p></blockquote><h4 id="1-先看图："><a href="#1-先看图：" class="headerlink" title="1. 先看图："></a>1. 先看图：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200608200059.png" alt=""></p><h4 id="2-代码："><a href="#2-代码：" class="headerlink" title="2. 代码："></a>2. 代码：</h4><blockquote><p>注意：代码中使用的节点类Node在本文的上面已经提供了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.linklist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: RotateLinkedListByDoublePointer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  通过双指针法 旋转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-06-07 16:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateLinkedListByDoublePointer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  旋转单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head   单链表 头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> placeNum  向右移动的位置数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">rotate</span><span class="params">(Node head, <span class="keyword">int</span> placeNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 临时节点</span></span><br><span class="line">        Node temp;</span><br><span class="line">        <span class="comment">// 将临时节点指向头结点</span></span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="comment">// 记录单链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历单链表得到其长度</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  如果单链表的长度小于移动的位置数</span></span><br><span class="line"><span class="comment">         * (注意：移动位置数是单链表长度的整数倍时，其实相当于单链表没有移动，还是原来的样式)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= placeNum)&#123;</span><br><span class="line">            <span class="comment">// 获取余数，也就是最终要向右移动的位置数</span></span><br><span class="line">            placeNum = placeNum % length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果余数为0，和上面所说的单链表其实没有变化的</span></span><br><span class="line">        <span class="keyword">if</span> (placeNum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点指针</span></span><br><span class="line">        Node current;</span><br><span class="line">        <span class="comment">// 前节点指针</span></span><br><span class="line">        Node previous;</span><br><span class="line">        current = head;</span><br><span class="line">        previous = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前指针是否移动了(要求移动的位置数)</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在当前指针移动了(要求的位置数)后，并且当前指针还未移动到单链表的尾节点的话，</span></span><br><span class="line"><span class="comment">             * 此时需要current、previous指针一起移动了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (i == placeNum)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                previous = previous.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在当前指针还未移动(要求的位置数)前，只有当前指针移动，previous指针不动</span></span><br><span class="line">                i++;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当 current指针移动到了链表的尾部后，此时指针移动结束，将当前previous、current指针截取的</span></span><br><span class="line"><span class="comment">         * 这段节点拼接到头节点前，并将previous指针指向的节点与后继结点断开连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node newTemp = previous.next;</span><br><span class="line">        previous.next = <span class="keyword">null</span>;</span><br><span class="line">        current.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newTemp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建单链表</span></span><br><span class="line">        Node head = Node.createLinkedList();</span><br><span class="line">        System.out.print(<span class="string">"新创建的单链表： "</span>);</span><br><span class="line">        <span class="comment">// 遍历新创建的单链表</span></span><br><span class="line">        Node.traverse(head);</span><br><span class="line">        <span class="comment">// 旋转链表，向右移动 10 个位置数</span></span><br><span class="line">        Node newHead = rotate(head, <span class="number">10</span>);</span><br><span class="line">        System.out.print(<span class="string">"反转后的单链表： "</span>);</span><br><span class="line">        <span class="comment">// 遍历反转后的单链表</span></span><br><span class="line">        Node.traverse(newHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530192854.gif" alt=""></p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AQS之CountDownLatch源码解析</title>
      <link href="/2020/05/31/AQS_CountDownLatch_source_code_analysis/"/>
      <url>/2020/05/31/AQS_CountDownLatch_source_code_analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>CountDownLatch（<strong>倒计数器</strong>）是JDK并发包下的一个同步工具类，其内部是依赖于AQS（<strong>AbstractQueuedSynchronizer</strong>）的 <strong>共享锁（共享模式）</strong>。</p></blockquote><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><blockquote><p>针对于 CountDownLatch 倒计时器， 一种典型的场景就是类似于<strong>火箭发射</strong>；在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检测，只有等到所有的检查完毕且没问题后，引擎才能点火。那么在检测环节中多个检测项可以同时并发进行的，只有所有检测项全部完成后，才会通知引擎点火的，这里可以使用 CountDownLatch 来实现。</p><p>CountDownLatch 到底是怎么实现的呢？别着急，<strong>模拟代码</strong>奉上：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200531143203.png" alt=""></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.aqs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SimulateRocketLaunchDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  使用 CountDownLatch 模拟火箭发射过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-05-31 14:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulateRocketLaunchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了 10 个检测项</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> SimulateRocketLaunchDemo demo = <span class="keyword">new</span> SimulateRocketLaunchDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 模拟检查任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName().split(<span class="string">"-"</span>)[<span class="number">3</span>]</span><br><span class="line">                    + <span class="string">" check complete ！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//计数减一</span></span><br><span class="line">            <span class="comment">//放在finally避免任务执行过程出现异常，导致countDown()不能被执行</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置线程数为10的固定线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待检查，只有当10个检测项全部检测完成后，才会唤醒处于等待状态的main主线程，让其继续执行</span></span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="comment">// 发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">"Fire!"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再提供一个CountDownLatch 的实际应用的例子，传送门：<a href="https://blog.csdn.net/feichitianxia/article/details/97814645" target="_blank" rel="noopener">懒汉式单例模式为什么要进行二次判空</a></p></blockquote><h2 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h2><blockquote><p>由于CountDownLatch 内部的实现是依赖于AQS的<strong>共享锁（共享模式）</strong>的， 所以在分析源码前，需要对AQS有基础的了解，如果对AQS一点也不知道的话，请通过 <a href="https://blog.csdn.net/feichitianxia/article/details/106319351" target="_blank" rel="noopener">AQS之ReentrantLock源码解析</a> 文章了解下AQS，这样在后面CountDownLatch 分析源码时会简单些。<br></p><p>什么是共享锁、排它锁？</p><p>①、共享锁：允许多个线程可以同时获取一个锁； （<strong>CountDownLatch</strong> 使用的共享锁）</p><p>②、排它锁：一个锁在同一时刻只运行一个线程拥有；（<strong>ReentrantLock</strong>  使用的排它锁）</p></blockquote><h4 id="1、接下来主要分析CountDownLatch的这几个方法："><a href="#1、接下来主要分析CountDownLatch的这几个方法：" class="headerlink" title="1、接下来主要分析CountDownLatch的这几个方法："></a>1、接下来主要分析CountDownLatch的这几个方法：</h4><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200531191044.png" alt=""></p><h4 id="2、构造方法-new-CountDownLatch-10-："><a href="#2、构造方法-new-CountDownLatch-10-：" class="headerlink" title="2、构造方法 new CountDownLatch(10) ："></a>2、构造方法 new CountDownLatch(10) ：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CountDownLatch内部维护了Sync内部类，内部类继承了AQS父类</span></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①、接下来看看 Sync 类的构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setState()方法是AQS提供的state变量的写方法， state变量被volatile修饰，由于volatile的</span></span><br><span class="line"><span class="comment">     * happen-before规则，被 volatile 修饰的变量单独读写操作具有原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②、然后在看看AQS提供的setState(int newCount) 方法 和  state变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、CountDownLatch的-getCount-方法："><a href="#3、CountDownLatch的-getCount-方法：" class="headerlink" title="3、CountDownLatch的 getCount( ) 方法："></a>3、CountDownLatch的 getCount( ) 方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 sync 内部类的getCount()方法</span></span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①、Sync 内部类的getCount( ) 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Sync 调用其父类AQS的 getState()方法</span></span><br><span class="line">    <span class="keyword">return</span> getState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②、AQS的getState(）方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回state同步状态值</span></span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、CountDownLatch-的-countDown-方法："><a href="#4、CountDownLatch-的-countDown-方法：" class="headerlink" title="4、CountDownLatch 的 countDown( ) 方法："></a>4、CountDownLatch 的 countDown( ) 方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Sync内部类的父类AQS的 releaseShared()共享锁释放模版方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①、AQS的 releaseShared( ) 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryReleaseShared()方法是尝试释放锁，这个方法在AQS的子类Sync进行了重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果tryReleaseShared()方法尝试释放锁成功，并且此时state同步状态变量值为0时，</span></span><br><span class="line"><span class="comment">         * 则执行doReleaseShared方法，将在同步队列中阻塞的线程唤醒</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②、CountDownLatch 的 tryReleaseShared( )方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for(;;) 与 while(true) 一样的死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取state同步变量值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果state同步变量值已经是0，则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 将state同步变量值进行减一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 使用AQS提供的CAS算法方法更新state变量值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 如果nextc等于0，代表此时state同步变量值为0了，返回true</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③、AQS提供的 doReleaseShared( ) 方法：<font color=red>唤醒同步队列中阻塞的线程</font></strong></p><blockquote><p>Node节点的四种状态值请<strong>参考文章</strong>：<a href="https://blog.csdn.net/feichitianxia/article/details/106319351" target="_blank" rel="noopener">AQS之ReentrantLock源码解析</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// head同步队列中的队列头</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获取head节点的状态，AQS中的Node内部节点类中定义了四种状态值</span></span><br><span class="line"><span class="comment">                 * 四种状态值请参考上面 ↑ 文章</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * SIGNAL是四中状态值之一：表示当前节点中的线程可以尝试被唤醒 </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="comment">// 将节点的状态使用CAS算法更新为0，0表示初始化状态</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="comment">// 状态更新0失败，则进行下次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;     </span><br><span class="line">                    <span class="comment">// 状态成功更新为0后，唤醒节点中的线程，此方法具体源码可参考上面 ↑ 文章</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果节点状态值为0，则使用CAS方法更新节点状态值为 Node.PROPAGATE</span></span><br><span class="line"><span class="comment">                 * PROPAGATE 是四中状态值之一：该状态表示可运行，只在共享模式下使用</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)  </span><br><span class="line">                <span class="comment">// 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5、CountDownLatch-的-await-方法："><a href="#5、CountDownLatch-的-await-方法：" class="headerlink" title="5、CountDownLatch 的 await( ) 方法："></a>5、CountDownLatch 的 await( ) 方法：</h4><blockquote><p>await( ) 方法：当state状态变量值不为0时，就一直将线程（main主线程）阻塞在同步队列中；当state变量值为0时，也会尝试将线程唤醒，并将唤醒操作传播下去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Sync内部类的父类AQS的模版方法 acquireSharedInterruptibly()方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①、AQS的模版方法  acquireSharedInterruptibly(1) 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * interrupted()判断当前线程是否被中断，注意：此方法会默认清除线程的中断标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryAcquireShared()尝试访问共享锁，如果state同步状态变量值不为0，则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将阻塞的线程创建Node节点，绑定节点类型为共享模式，并将创建的节点加入同步队列的队尾</span></span><br><span class="line"><span class="comment">         * 并且当新创建的Node节点的前驱结点为head时，就会尝试唤醒下一个节点中的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②、AQS提供的 doAcquireSharedInterruptibly( ) 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新Node节点，绑定共享模式，并将其插入到队尾</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// failed是中断标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 返回当前节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 判断当前state同步变量值是否为0，不是0返回-1，是0返回1</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果 r大于0，表示state变量值为0</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将当前节点设置head队列头，并且尝试唤醒同步队列中阻塞的线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * shouldParkAfterFailedAcquire()是对当前节点的前驱结点的状态进行判断，以及去针对各种</span></span><br><span class="line"><span class="comment">             * 状态做出相应处理，由于文章篇幅问题，具体源码本文不做讲解；只需知道如果前驱结点p的状态为</span></span><br><span class="line"><span class="comment">             * SIGNAL的话，就返回true。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * parkAndCheckInterrupt()方法会使当前线程进去waiting状态，并且查看当前线程是否被中断，</span></span><br><span class="line"><span class="comment">             * interrupted() 同时会将中断标志清除。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果for(;;)循环中出现异常，并且failed=false没有执行的话,cancelAcquire方法</span></span><br><span class="line"><span class="comment">             * 就会将当前线程的状态置为 node.CANCELLED 已取消状态，并且将当前节点node移出</span></span><br><span class="line"><span class="comment">             * 同步队列。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③、AQS提供的 setHeadAndPropagate( ) 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    <span class="comment">// 设置为队首</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果s节点是共享模式的，则调用doReleaseShared()方法</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 唤醒阻塞在同步队列中的线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>end，本文解析 CountDownLatch 源码已经写完了，如果大家在看的时候，有些地方没看明白的话，请先将这篇文章  <a href="https://blog.csdn.net/feichitianxia/article/details/106319351" target="_blank" rel="noopener">AQS之ReentrantLock源码解析</a>  熟悉下，这篇文章中简单讲解了 AQS的原理，并且着重讲解了独占模式（排它锁）的 ReentrantLock，可以将这两块看完，在来看 CountDownLatch 就会感觉简单些，逻辑也更加清晰些。</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS队列同步器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表反转？面试官你确定要问这个吗？</title>
      <link href="/2020/05/30/Single_linked_list_inversion/"/>
      <url>/2020/05/30/Single_linked_list_inversion/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>单链表是一种常见、重要的数据结构，并且随着时间飞逝，也衍生出了诸多针对单链表的操作算法，例如，今天本文中即将会聊到的<font color=red><strong>单链表的反转操作</strong> </font>。</p><p>下面会结合一些图片详细讲解下单链表的数据结构，以及通过三种方式（递归、双指针法、循环遍历）进行单链表的反转。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530152024.gif" style="zoom:50%;" /><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><h4 id="1、单链表的数据结构："><a href="#1、单链表的数据结构：" class="headerlink" title="1、单链表的数据结构："></a>1、单链表的数据结构：</h4><blockquote><p>单链表是一种线性结构，它是由一个个<font color=red><strong>节点（Node）</strong>组成的</font>。并且每个节点（Node）是由一块<font color=red><strong>数据域（data）</strong></font>和一块<font color=red><strong>指针域（next）</strong></font>组成的。 &nbsp;&nbsp;&nbsp;&nbsp; </p></blockquote><p>①、节点（Node）结构图如下：</p><blockquote><ol><li><strong>节点的数据域</strong>：data数据域一般就是用来存放数据的 。（注：data域需要指定类型，只能存放指定类型的数据，不能什么东西都放，是不是呀； 那代码中是怎么实现的呢？ 使用 <strong>泛型</strong>  。）</li><li><strong>节点的指针域</strong>：next指针域一般就是存放的指向下一个节点的指针；这个指针其实是一个内存地址，因为Node节点对象是存放在JVM中的堆内存中，所以节点的next指针域中存放就是下一个节点在堆内存中的地址；而在代码中对象的内存地址是赋值给其引用变量了，所以<strong>指针域中存放的是下一个节点对象的引用变量</strong>。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530154558.png" alt=""></p><p>②、单链表结构图如下：（<strong>下图是由三个节点构成的单链表</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530154552.png" alt=""></p><blockquote><p>若有所思，en en en . . .  . . .   好像单链表的知识在脑海中清晰了些呀；那要不我们快马加鞭，赶紧把单链表的数据结构代码弄出来，然后再思索下怎么进行反转， en en en. . . .. . .     嘿嘿！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530161055.gif" alt=""></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><h4 id="1、Node节点类："><a href="#1、Node节点类：" class="headerlink" title="1、Node节点类："></a>1、Node节点类：</h4><blockquote><p>创建Node节点类，节点类中并且额外提供了两个方法（单链表的创建方法、单链表的遍历放歌）；</p><p>注意：单链表的创建方法 createLinkedList( )：Node节点的插入方式为 <font color=red><strong>尾插法</strong></font> ， 其实还有 <strong>头插法</strong> 方式；</p><p>扩展：链表中节点的插入方式还在 <strong>HashMap</strong> 中使用到了，<strong>在 JDK 1.7 时是头插法，JDK 1.8时是尾插法</strong>；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.linklist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Node  节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  单链表的组成元素：Node节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-05-30 16:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点的数据域</span></span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="comment">// 节点的指针域</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据域值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 单链表 （尾插法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 头节点</span></span><br><span class="line">        Node&lt;String&gt; head;</span><br><span class="line"></span><br><span class="line">        Node&lt;String&gt; n = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"111"</span>);</span><br><span class="line">        Node&lt;String&gt; n1 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"222"</span>);</span><br><span class="line">        Node&lt;String&gt; n2 = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"333"</span>);</span><br><span class="line">        <span class="comment">// 指定头节点</span></span><br><span class="line">        head = n;</span><br><span class="line">        n.next = n1;</span><br><span class="line">        n1.next = n2;</span><br><span class="line">        <span class="comment">// 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">" --&gt; "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"null"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、单链表反转："><a href="#2、单链表反转：" class="headerlink" title="2、单链表反转："></a>2、单链表反转：</h4><h5 id="①、递归实现反转："><a href="#①、递归实现反转：" class="headerlink" title="①、递归实现反转："></a>①、递归实现反转：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.linklist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ReverseByRecursiveTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用递归实现单链表反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-05-30 17:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseByRecursiveTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 递归 实现单链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  链表的 头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回反转后的 head 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取头结点的下个节点，使用temp临时节点存储</span></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        Node node = reverse(head.next);</span><br><span class="line">        <span class="comment">// 将头节点的下一个节点的指针域指向头节点</span></span><br><span class="line">        temp.next = head;</span><br><span class="line">        <span class="comment">// 将头节点的指针域置为null</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建单链表</span></span><br><span class="line">        Node head = Node.createLinkedList();</span><br><span class="line">        <span class="comment">// 遍历新创建的单链表</span></span><br><span class="line">        System.out.print(<span class="string">"新创建的单链表： "</span>);</span><br><span class="line">        Node.traverse(head);</span><br><span class="line">        <span class="comment">// 递归反转单链表</span></span><br><span class="line">        Node newHead = reverse(head);</span><br><span class="line">        <span class="comment">// 遍历反转后的单链表</span></span><br><span class="line">        System.out.print(<span class="string">"反转后的单链表： "</span>);</span><br><span class="line">        Node.traverse(newHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行输出：</p><p>新创建的单链表： 111 –&gt; 222 –&gt; 333 –&gt; null<br>反转后的单链表： 333 –&gt; 222 –&gt; 111 –&gt; null</p></blockquote><p><strong>图解递归方法的调用过程：</strong></p><p>（1）、首先将头结点（data域为 111 节点）传入 reverse( ) 方法中，并将方法压入栈：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530185130.png" alt=""></p><p>（2）、当执行到  <strong>Node node = reverse(head.next);</strong>   将 data域为 222 的节点传入 reverse( ) 方法中，并将方法压入栈：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530185125.png" alt=""></p><p>（3）、当执行到  <strong>Node node = reverse(head.next);</strong>   将 data域为 333 的节点传入 reverse( ) 方法中，并将方法压入栈； 然后当执行到 <strong>if</strong> 判断时，发现 data 域为 333 的节点的 next 指针域指向的下一个节点为 null，此时方法返回当前head头结点（data域为 333 的节点）：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530184205.png" alt=""></p><p>（4）、当 <strong>reverse(333) ;</strong> 方法出栈时，此时会继续执行 <strong>reverse(222) ;</strong>   继续执行递归调用后面的代码，并且执行完后， *<em>reverse(222) *</em> 方法出栈：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530184211.png" alt=""></p><p>（5）、当 <strong>reverse(222) ;</strong> 方法出栈时，此时会继续执行 <strong>reverse(111) ;</strong>   继续执行递归调用后面的代码，并且执行完后， *<em>reverse(111) *</em> 方法出栈：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530184216.png" alt=""></p><p>（6）、当<strong>reverse(111) ** 方法出栈了，那么</strong>此时递归调用结束**， 最终堆中的单链表的结构如图：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530184221.png" alt=""></p><blockquote><p>递归调用终于写完了，这个图太费劲了，花费了太多时间了；画图所使的工具是：<strong>ProcessOn</strong> 。</p></blockquote><h5 id="②、循环遍历-辅助空间-实现反转："><a href="#②、循环遍历-辅助空间-实现反转：" class="headerlink" title="②、循环遍历+辅助空间 实现反转："></a>②、循环遍历+辅助空间 实现反转：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.linklist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ReverseByTraverseTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  使用 循环遍历+辅助空间 进行单链表反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-05-30 19:11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseByTraverseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 遍历+辅助空间 进行链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回反转后的 head 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// list集合 辅助空间</span></span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Node n = list.get(i);</span><br><span class="line">            Node n1 = list.get(i-<span class="number">1</span>);</span><br><span class="line">            n.next = n1;</span><br><span class="line">            n1.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建单链表</span></span><br><span class="line">        Node head = Node.createLinkedList();</span><br><span class="line">        <span class="comment">// 遍历新创建的单链表</span></span><br><span class="line">        System.out.print(<span class="string">"新创建的单链表： "</span>);</span><br><span class="line">        Node.traverse(head);</span><br><span class="line">        <span class="comment">// 递归反转单链表</span></span><br><span class="line">        Node newHead = reverse(head);</span><br><span class="line">        <span class="comment">// 遍历反转后的单链表</span></span><br><span class="line">        System.out.print(<span class="string">"反转后的单链表： "</span>);</span><br><span class="line">        Node.traverse(newHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③、双指针-辅助临时节点-实现反转："><a href="#③、双指针-辅助临时节点-实现反转：" class="headerlink" title="③、双指针+辅助临时节点  实现反转："></a>③、双指针+辅助临时节点  实现反转：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: com.lyl.linklist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ReverseByDoublePointerTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  使用 双指针+辅助临时节点 实现单链表反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-05-30 19:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseByDoublePointerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 双指针+辅助临时节点 进行链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回反转后的 head 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前节点指针</span></span><br><span class="line">        Node current ;</span><br><span class="line">        <span class="comment">// 前一节点指针</span></span><br><span class="line">        Node previous;</span><br><span class="line">        <span class="comment">// 当前节点指针初始化指向头结点</span></span><br><span class="line">        current = head;</span><br><span class="line">        <span class="comment">// 前一节点指针初始化为 null</span></span><br><span class="line">        previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 辅助的临时节点, 存储当前节点的下一个节点</span></span><br><span class="line">            Node temp = current.next;</span><br><span class="line">            <span class="comment">// 当前节点的下一个节点指向了前一个节点指针指向的节点</span></span><br><span class="line">            current.next = previous;</span><br><span class="line">            <span class="comment">// 然后 前一节点指针向前移动一个节点，此时和当前节点指针都指向了当前节点</span></span><br><span class="line">            previous = current;</span><br><span class="line">            <span class="comment">// 当前节点指针也向前移动一个节点，也就是移动到了当前节点的下一个节点，就是临时节点指向的节点</span></span><br><span class="line">            current = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建单链表</span></span><br><span class="line">        Node head = Node.createLinkedList();</span><br><span class="line">        <span class="comment">// 遍历新创建的单链表</span></span><br><span class="line">        System.out.print(<span class="string">"新创建的单链表： "</span>);</span><br><span class="line">        Node.traverse(head);</span><br><span class="line">        <span class="comment">// 递归反转单链表</span></span><br><span class="line">        Node newHead = reverse(head);</span><br><span class="line">        <span class="comment">// 遍历反转后的单链表</span></span><br><span class="line">        System.out.print(<span class="string">"反转后的单链表： "</span>);</span><br><span class="line">        Node.traverse(newHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530192854.gif" alt=""></p><blockquote><p>end，终于写完，本文中着重讲解了下 递归 的调用过程，因为递归一般是不太好理解的 。</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><font color=red>❤</font>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AQS之ReentrantLock源码解析</title>
      <link href="/2020/05/24/AQS_ReentLock_source_code_analysis/"/>
      <url>/2020/05/24/AQS_ReentLock_source_code_analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java中的同步类<strong>ReentrantLock</strong>是基于AbstractQueuedSynchronizer（简称为<strong>AQS</strong>）实现的。</p><p>今天从源码来了解下<strong>ReentrantLock</strong>中非公平锁的加锁和释放锁（<strong>ReentrantLock</strong>中支持公平锁和非公平锁，默认是非公平锁的，但可以通过创建<strong>ReentrantLock</strong>对象时传入参数指定使用公平锁）。</p><p>在了解<strong>ReentrantLock</strong>前，需要对<strong>AQS</strong>有一定的了解，否则在学习时会比较困难的，并且在通过源码学习<strong>ReentrantLock</strong>时也会穿插着讲解<strong>AQS</strong>内容。</p></blockquote><h2 id="AQS扫荡："><a href="#AQS扫荡：" class="headerlink" title="AQS扫荡："></a>AQS扫荡：</h2><h4 id="1-0、AQS中state变量"><a href="#1-0、AQS中state变量" class="headerlink" title="1.0、AQS中state变量"></a>1.0、AQS中state变量</h4><p>​        AQS中提供了一个int类型的<strong>state</strong>变量，并且<strong>state</strong>变量被<strong>volatile</strong>修饰，表示<strong>state</strong>变量的<strong>读写操作</strong>可以保证原子性；并且AQS还提供了针对<strong>state</strong>变量的读写方法，以及使用CAS算法更新<strong>state</strong>变量的方法。<font size="3" color="red"> AQS使用<strong>state</strong>变量这个状态变量来实现同步状态。</font></p><p><strong>①、源码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get 获取state变量值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set 更新state变量值 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState  新的状态变量值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CAS算法更新state变量值; 当从共享内存中读取出的state变量值与expect期望值一致的话，</span></span><br><span class="line"><span class="comment"> * 就将其更新为update值。使用CAS算法保证其操作的原子性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect  期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update  更新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Unsafe类的本地方法来实现CAS</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1、state同步状态的竞争"><a href="#1-1、state同步状态的竞争" class="headerlink" title="1.1、state同步状态的竞争"></a>1.1、state同步状态的竞争</h4><p>​        多个线程同时竞争AQS的<strong>state同步状态</strong>，在同一时刻只能有一个线程获取到同步状态（获取到锁），那其它没获取到锁的线程该怎么办呢<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085104.gif" alt=""></p><blockquote><p>它们会进去到一个同步队列中，在队列中等待同步锁的释放；</p><p>这个同步队列是一个<font size="3" color="red"><strong>基于链表的双向队列</strong></font> ,  基于链表的话，就会存在<strong>Node节点</strong>，那么AQS中节点是怎么实现的呢<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085104.gif" alt=""></p></blockquote><p><strong>①、Node节点：</strong></p><p>AQS中自己实现了一个内部Node节点类，Node节点类中定义了一些属性，下面来简单说说属性的意思：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标志在同步队列中Node节点的模式，共享模式 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// 标志在同步队列中Node节点的模式，独占（排他）模式 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitStatus值为1时表示该线程节点已释放（超时等），已取消的节点不会再阻塞。 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// waitStatus值为-1时表示当此节点的前驱结点释放锁时，然后当前节点中的线程就可以去获取锁运行 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus为-2时，表示该线程在condition队列中阻塞（Condition有使用），</span></span><br><span class="line"><span class="comment">         * 当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从</span></span><br><span class="line"><span class="comment">         * 等待队列转移到同步队列中，等待获取同步锁。</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus为-3时，与共享模式有关，在共享模式下，该状态表示可运行</span></span><br><span class="line"><span class="comment">         * （CountDownLatch中有使用）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus：等待状态，指的是当前Node节点中存放的线程的等待状态，</span></span><br><span class="line"><span class="comment">         * 等待状态值就是上面的四个状态值：CANCELLED、SIGNAL、CONDITION、PROPAGATE</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为同步队列是双向队列，那么每个节点都会有指向前一个节点的 prev 指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为同步队列是双向队列，那么每个节点也都会有指向后一个节点的 next 指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Node节点中存放的阻塞的线程引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前节点与其next后继结点的所属模式，是SHARED共享模式，还是EXCLUSIVE独占模式，</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 注：比如说当前节点A是共享的，那么它的这个字段是shared，也就是说在这个等待队列中，</span></span><br><span class="line"><span class="comment">         * A节点的后继节点也是shared。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前节点是否为共享模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前节点的 prev前驱结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在后面的addWaiter方法会使用到，线程竞争state同步锁失败时，会创建Node节点存放thread</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     </span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>②、同步队列结构图（双向队列）：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524090454.png" alt=""></p><h4 id="1-2、图解AQS原理"><a href="#1-2、图解AQS原理" class="headerlink" title="1.2、图解AQS原理"></a>1.2、图解AQS原理</h4><p>​       通过前面两点，可以了解到AQS的原理到底是什么了，总结为一句话：<font size="3" color="red">AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</font></p><p> 然后再来一张图，使得理解更加深刻：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524160423.png" alt=""></p><p> 图片来源： <a href="https://www.jianshu.com/p/da9d051dcc3d" target="_blank" rel="noopener">Java技术之AQS详解</a></p><blockquote><p>好了，<strong>AQS</strong>暂时可以先了解到这里了，知道这些后，在后面了解<strong>ReentrantLock</strong>时就会变的容易些，并且后面通过源码学习<strong>ReentrantLock</strong>时，由于会使用到AQS的模版方法，所以也会讲解到AQS的内容。</p></blockquote><h2 id="剑指ReentrantLock源码："><a href="#剑指ReentrantLock源码：" class="headerlink" title="剑指ReentrantLock源码："></a>剑指<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524094904.gif" alt="">ReentrantLock源码：</h2><h4 id="2-0、ReentrantLock-vs-Synchronized"><a href="#2-0、ReentrantLock-vs-Synchronized" class="headerlink" title="2.0、ReentrantLock  vs  Synchronized"></a>2.0、ReentrantLock <font size="6" color="red"> vs </font> Synchronized</h4><p>​       在了解<strong>ReentrantLock</strong>之前，先将<strong>ReentrantLock</strong>与<strong>Synchronized</strong>进行比较下，这样可以更加了解<strong>ReentrantLock</strong>的特性，也有助于下面源码的阅读；</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524122513.png" alt=""></p><h4 id="2-1、ReentrantLock的公平锁与非公平锁"><a href="#2-1、ReentrantLock的公平锁与非公平锁" class="headerlink" title="2.1、ReentrantLock的公平锁与非公平锁"></a>2.1、ReentrantLock的公平锁与非公平锁</h4><p>创建一个<strong>ReentrantLock</strong>对象，在创建对象时，如果不指定公平锁的话，默认是非公平锁；</p><p><strong>①、简单了解下什么是公平锁，什么是非公平锁？</strong></p><blockquote><p>公平锁：按照申请同步锁的顺序来获取锁；</p><p>非公平锁：不会按照申请锁的顺序获取锁，存在锁的抢占；</p><p><font size="3" color="red">注：后面会通过源码了解下非公平锁和公平锁是怎样获取锁的。</font></p></blockquote><p><strong>②、源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是非公平的锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 构造方法默认创建了一个 NonfairSync 非公平锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NonfairSync继承了Sync类，Sync类又继承了AQS类</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入参数 true，指定为公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 传入参数的构造方法，当fair为true时，创建一个公平锁对象，否则创建一个非公平锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、通过源码看下非公平锁的加锁机制：（独占模式）"><a href="#2-2、通过源码看下非公平锁的加锁机制：（独占模式）" class="headerlink" title="2.2、通过源码看下非公平锁的加锁机制：（独占模式）"></a>2.2、通过源码看下<strong>非公平锁</strong>的加锁机制：（独占模式）</h4><p>①、开始先通过一个简单流程图来看下独占模式下加锁的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524152416.png" alt=""></p><p>​          图片来源：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">美团技术团队</a></p><p>②、源码分析：加锁时首先使用CAS算法尝试将state状态变量设置为1，设置成功后，表示当前线程获取到了锁，然后将独占锁的拥有者设置为当前线程；如果CAS设置不成功，则进入Acquire方法进行后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用CAS算法尝试将state状态变量设置为1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置成功后，表示当前线程获取到了锁，然后将独占锁的拥有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 进行后续处理，会涉及到重入性、创建Node节点加入到队列尾等</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、探究下<strong>acquire(1)</strong> 方法里面是什么呢<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085104.gif" alt="">   acquire(1) 方法是AQS提供的   <strong>模版方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用tryAcquire()方法，让当前线程尝试获取同步锁，获取成的话，就不会执行后面的acquireQueued()</span></span><br><span class="line"><span class="comment">     * 方法了，这是由于 &amp;&amp; 逻辑运算符的特性决定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果使用tryAcquire()方法获取同步锁失败的话，就会继续执行acquireQueued（）方法，它的作用是</span></span><br><span class="line"><span class="comment">     * 一直死循环遍历同步队列，直到使addWaiter()方法创建的节点中线程获取到锁。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果acquireQueued()返回的true，这个true不是代表成功的获取到锁，而是代表当前线程是否存在</span></span><br><span class="line"><span class="comment">     * 中断标志，如果存在的话，在获取到同步锁后，需要使用selfInterrupt()对当前线程进行中断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）</strong>、<strong>tryAcquire(arg)</strong> 方法源码解读：NonfairSync 非公平锁中重写了AQS的tryAcquire()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前state同步状态变量值，由于使用volatile修饰，单独的读写操作具有原子性</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果状态值为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用compareAndSetState方法这个CAS算法尝试将state同步状态变量设置为1 获取同步锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 然后将独占锁的拥有者设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果拥有独占锁的的线程是当前线程的话,表示当前线程需要重复获取锁（重入锁）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前同步状态state变量值加1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 写入state同步状态变量值，由于使用volatile修饰，单独的读写操作具有原子性</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）</strong>、<strong>addWaiter( Node.EXCLUSIVE )</strong> ：创建一个同步队列Node节点，同时绑定节点的模式为独占模式，并且将创建的节点插入到同步队列尾部；addWaiter( ) 方法是AQS提供方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// model参数是独占模式，默认为null；</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将当前同步队列的tail尾节点的地址引用赋值给pre变量</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果pre不为null，说明同步队列中存在节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点的前驱结点指向pre尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS算法将当前节点设置为尾节点，使用CAS保证其原子性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 尾节点设置成功，将pre旧尾节点的后继结点指向新尾节点node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果尾节点为null，表示同步队列中还没有节点，enq（）方法将当前node节点插入到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）</strong>、说完addWaiter( Node.EXCLUSIVE )方法，接下来说下<strong>acquireQueued（）</strong>方法，它是怎样使addWaiter()创建的节点中的线程获取到state同步锁的。（这个方法也是AQS提供的）  <img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085622.gif" alt="">    </p><p><strong>源码走起：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标志cancelAcquire()方法是否执行</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标志是否中断，默认为false不中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果当前节点的前驱结点已经是同步队列的头结点了，说明了两点内容：</span></span><br><span class="line"><span class="comment">             * 1、其前驱结点已经获取到了同步锁了,并且锁还没释放</span></span><br><span class="line"><span class="comment">             * 2、其前驱结点已经获取到了同步锁了，但是锁已经释放了</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 然后使用tryAcquire()方法去尝试获取同步锁，如果前驱结点已经释放了锁，那么就会获取成功，</span></span><br><span class="line"><span class="comment">             * 否则同步锁获取失败，继续循环</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为同步队列的head头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 然后将当前节点的前驱结点的后继结点置为null，帮助进行垃圾回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断的标志</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * shouldParkAfterFailedAcquire()是对当前节点的前驱结点的状态进行判断，以及去针对各种</span></span><br><span class="line"><span class="comment">             * 状态做出相应处理，由于文章篇幅问题，具体源码本文不做讲解；只需知道如果前驱结点p的状态为</span></span><br><span class="line"><span class="comment">             * SIGNAL的话，就返回true。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * parkAndCheckInterrupt()方法会使当前线程进去waiting状态，并且查看当前线程是否被中断，</span></span><br><span class="line"><span class="comment">             * interrupted() 同时会将中断标志清除。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 中断标志置为true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果for(;;)循环中出现异常，并且failed=false没有执行的话,cancelAcquire方法</span></span><br><span class="line"><span class="comment">             * 就会将当前线程的状态置为 node.CANCELLED 已取消状态，并且将当前节点node移出</span></span><br><span class="line"><span class="comment">             * 同步队列。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）</strong>、最后说下 <strong>selfInterrupt()</strong> 方法， 这个方法就是将当前线程进行中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中断当前线程</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、公平锁与非公平锁在加锁时的区别："><a href="#2-3、公平锁与非公平锁在加锁时的区别：" class="headerlink" title="2.3、公平锁与非公平锁在加锁时的区别："></a>2.3、公平锁与非公平锁在加锁时的区别：</h4><p>①、公平锁 <strong>FairSync</strong> 的加锁 <strong>lock()</strong> 加锁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、非公平锁 <strong>NonfairSync</strong> 的加锁 <strong>lock()</strong> 加锁方法：上面讲解源码的时候有提到哟，还有印象吗，没印象的话也没关系，不要哭<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085618.gif" alt="">  ，  嘿嘿，我都准备好了<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085118.gif" alt="">。  源码奉上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 看到这，是不是发现了什么，非公平锁在此处直观看的话，发现比公平锁多了这几行代码; </span></span><br><span class="line"><span class="comment">     * 这里就是使得线程存在了一个抢占，如果当前同步队列中的head头结点中 线程A 刚好释放了同步锁，</span></span><br><span class="line"><span class="comment">     * 然后此时 线程B 正好来了，那么此时线程B就会获取到锁，而此时同步队列中head头结点的后继结点中的</span></span><br><span class="line"><span class="comment">     * 线程C 就无法获取到同步锁，只能等待线程B释放锁后，尝试获取锁了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、除了上面那处不同之外，还有别的地方吗；别急，再看看 <strong>acquire(1)</strong>  方法是否一样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        诶呀，方法点进去都是一样的呀，可不嘛，都是调用的AQS提供的 <strong>acquire(1)</strong>  方法；但是别着急，上面在讲解非公平锁加锁时，有提到的 <strong>tryAcquire(arg)</strong> 方法在AQS的不同子孙类中都有各自的实现的。现在打开公平锁的 <strong>tryAcquire(arg)</strong>  方法看看其源码与非公平锁有什么区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过对比源码发现，公平锁比非公平锁多了这块代码： !hasQueuedPredecessors() </span></span><br><span class="line"><span class="comment">         * hasQueuedPredecessors() 是做什么呢？就是判断当前同步队列中是否存在节点，如果存在节点呢，</span></span><br><span class="line"><span class="comment">         * 就返回true，由于前面有个 ！，那么就是false，再根据 &amp;&amp; 逻辑运算符的特性，不会继续执行了;</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * tryAcquire()方法直接返回false，后面的逻辑就和非公平锁的一致了，就是创建Node节点，并将</span></span><br><span class="line"><span class="comment">         * 节点加入到同步队列尾; 公平锁：发现当前同步队列中存在节点，有线程在自己前面已经申请可锁，那</span></span><br><span class="line"><span class="comment">         * 自己就得乖乖的向后面排队去。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 友情提示：在生活中，我们也需要按照先来后到去排队，保证素质; 还有就是怕你们不排队被别人打了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>松口气，从中午一直写到下午快四点了，先让我歇口气，快累成狗了；本文还剩下释放锁部分没写呢，歇口气，喝口水继续<img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200524085639.gif" alt="">。</p><p><font size="3" color="red">注意：ReentrantLock在释放锁的时候，并不区分<strong>公平锁和非公平锁</strong>。</font></p></blockquote><h4 id="2-4、通过源码看下释放锁机制：（独占模式）"><a href="#2-4、通过源码看下释放锁机制：（独占模式）" class="headerlink" title="2.4、通过源码看下释放锁机制：（独占模式）"></a>2.4、通过源码看下释放锁机制：（独占模式）</h4><p>①、<strong>unlock()</strong>  释放锁的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁时，需要将state同步状态变量值进行减 1，传入参数 1</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、<strong>release( int arg )</strong> 方法解析：（此方法是AQS提供的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryRelease方法：尝试释放锁，成功true，失败false</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况,然后唤醒此阻塞的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3" color="red">注意：这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</font></p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p><p>h != null &amp;&amp; waitStatus == 0  表明后继节点对应的线程仍在运行中，不需要唤醒。</p><p>h != null &amp;&amp; waitStatus  &lt;  0  表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>③、然后再来看看<strong>tryRelease(arg)</strong>  方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前state状态值进行减一</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前独占锁的拥有者不是当前线程，则抛出 非法监视器状态 异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新state同步状态值</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、最后看看<strong>unparkSuccessor(Node node)</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点waitStatus</span></span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">Node s = node.next;</span><br><span class="line"><span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled状态的节点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line"><span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点的后继结点不为null，则将其节点中处于阻塞状态的线程unpark唤醒</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3" color="red">注意：为什么要从后往前找第一个非Cancelled的节点呢？原因如下:</font></p><p>由于之前加锁时的addWaiter( )方法的原因；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// model参数是独占模式，默认为null；</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将当前同步队列的tail尾节点的地址引用赋值给pre变量</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果pre不为null，说明同步队列中存在节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点的前驱结点指向pre尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS算法将当前节点设置为尾节点，使用CAS保证其原子性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 尾节点设置成功，将pre旧尾节点的后继结点指向新尾节点node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果尾节点为null，表示同步队列中还没有节点，enq（）方法将当前node节点插入到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，节点入队并不是原子操作，也就是说，<font size="3" color="blue">node.prev = pred ;   compareAndSetTail( pred, node ) </font>这两个地方可以看作Tail入队的原子操作，但是此时  <font size="3" color="red">pred.next =  node; </font> 还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，<font size="3" color="red">在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开</font>，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><blockquote><p>end！ 长吸一口气，终于本文算是写完了，最后再看看有没有错别字，以及排排版。</p><p>后续还会出一篇结合<strong>CountDownLatch</strong>源码学习共享锁（共享模式）的文章。</p></blockquote><table><tbody><tr><td bgcolor="#FF00FF"><font size="5" color="#fffff">谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></tbody></table><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">1、从ReentrantLock的实现看AQS的原理及应用</a><br><a href="https://www.jianshu.com/p/da9d051dcc3d" target="_blank" rel="noopener">2、Java技术之AQS详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS队列同步器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟实战排查堆内存溢出（java.lang.OutOfMemoryError Java heap space）问题</title>
      <link href="/2020/05/15/simulation_heap_OutOfMemory_screening/"/>
      <url>/2020/05/15/simulation_heap_OutOfMemory_screening/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>模拟实战中排查堆内存溢出（<font color="red"><strong>java.lang.OutOfMemoryError: Java heap space</strong></font >）的问题。<br>堆内存溢出的原因：一般都是创建了大量的对象，这些对象一直被引用着，无法被GC垃圾回收掉，最终导致堆内存被占满，没有足够的空间存放新创建的对象时，就会出现堆内存溢出问题。<br>在实际的业务场景中出现内存溢出的问题，排查起来一般是十分困难繁琐的，本文将通过结合一个简单的实例来阐述排查的具体思路和步骤。</p></blockquote><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><blockquote><p>注意：<font color="red">在实际场景中，一般都是部署在Linux服务器中的项目报出内存溢出的问题；为了尽可能还原出实际场景，本文也是将提前编写好的可以触发内存溢出的代码并打包成可运行的Jar包，然后放到服务器中执行的。</font></p></blockquote><p><strong>1、准备可导致内存溢出的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfMemory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutOfMemory</span><span class="params">(String test)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test = test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟内存溢出的发生</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;OutOfMemory&gt; list = <span class="keyword">new</span> ArrayList&lt;OutOfMemory&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 无限创建OutOfMemory对象，直至将堆空间占满，并且创建的OutOfMemory对象一直被list集合对象引用着，</span></span><br><span class="line"><span class="comment">         * 导致GC也无法回收，最终出现堆内存溢出问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="keyword">new</span> OutOfMemory(<span class="string">"5656"</span>));</span><br><span class="line">        System.out.println(<span class="string">"5656"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><tbody><tr><td bgcolor="#FF00FF"><font size="4" color="#fffff">代码编写完成后，使用开发工具导出<B>可运行的Jar包</B>— （TestOOM.jar）</font></td></tr></tbody></table><br><p><strong>2、准备Linux服务器</strong></p><blockquote><p>可以直接使用centos或者Red Hat等都可以；</p></blockquote><h2 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h2><p><strong>1、将可运行的Jar包放到服务器中执行：</strong><br>①、可使用xshell、xftp工具将可运行的Jar包（Jar包叫：<font color="red"><strong>TestOOM.jar</strong></font>）放入到服务器中；<br>②、使用命令执行Jar包；命令：<br>       &nbsp;&nbsp; &nbsp; java <font color="red"> -Xms40m -Xmx70m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/tmp</font> -jar TestOOM.jar</p><p>  &nbsp;&nbsp; &nbsp; 注意：为了尽快模拟发生堆内存溢出，所以在启动Jar包时，设置了一些参数；参数解析：<br>  &nbsp;&nbsp; &nbsp; 1）、 -Xms40m   初始堆大小设置为40m<br>  &nbsp;&nbsp; &nbsp; 2）、 -Xmx70m   最大堆大小设置为70m<br>  &nbsp;&nbsp; &nbsp; 3）、 -XX:+HeapDumpOnOutOfMemoryError   出现堆内存溢出时，自动导出堆内存 dump 快照<br>  &nbsp;&nbsp; &nbsp; 4）、 -XX:HeapDumpPath=/usr/tmp   设置导出的堆内存快照的存放地址为 /usr/tmp</p><p><strong>2、执行成功后，使用JVM监控命令监控JVM的信息：</strong><br>①、jps命令：此命令是用来查询与Java相关的进程的，并输出进程号；下图就是展示上面运行的Jar包的进程号：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTMxMC5wbmc?x-oss-process=image/format,png" alt=""><br>②、jmap命令：<font color="red"> jmap -heap 3324 </font>    &nbsp;此命令是查询出进程号为 3324 的JVM中堆内存信息；如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTMyMy5wbmc?x-oss-process=image/format,png" alt=""></p><blockquote><p>在图中可以发现堆内存中新生代、年老代中 free 可用空间越来越小，这预示着即将会发生GC垃圾回收，从而使堆腾出更多的空间存放新创建的对象。</p></blockquote><p>③、jstat命令：使用其监控JVM的性能信息；例如：在本次排查内存溢出的问题中，会使用 jstat 命令监控 JVM的 GC垃圾回收的情况；<br>&nbsp;&nbsp; 命令：<font color="red"> jstat -gcutil 3324 1000 </font>  &nbsp;  意思是每1000毫秒查询一次进程号为3324 的JVM的GC垃圾回收的情况；如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTMxOC5wbmc?x-oss-process=image/format,png" alt=""></p><blockquote><p>（1）、 YGC(堆中新生代GC)、FGC( FULL GC)为什么触发频率这么快呢？<br>答：由于堆内存空间不够用了，需要通过GC垃圾回收将一些空间进行回收，用于存放新创建的对象。</p></blockquote><blockquote><p>（ 2）、当堆内存空间不够用时，GC具体会发生什么呢？<br>答：<br>【1】、当堆中的新生代空间不够用时，会触发YGC（又称之为 Minor GC），对堆中新生代空间进行垃圾回收后，在剩余存活<br>的对象中，如果有对象的 <font color=blue> <strong>“晋升年龄达“ 到 “晋升年龄阈值” 后</strong>  </font>  ，就会将其移动到堆中老年代存储，所以每次YGC后，堆中年老代中存储的对象数量可能会增大；<br><font color=red> <strong>注意：晋升年龄：指新生代中的对象每经历一次 YGC，晋升年龄加1；</strong> </font><br><font color=red> <strong>注意：晋升年龄阈值：在Serial和ParNew GC两种回收器中，“晋升年龄阈值” 可通过参数MaxTenuringThreshold设定，默认值为15。</strong> </font><br>上面的 “晋升年龄” 来自： <a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化</a></p><p>【2】、当堆的新生代即将发生YGC时，如果发现新生代中存活下来的对象中达到“晋升年龄阈值”的对象所占用的空间比堆中年老代中剩余的可用空间大的话，就会直接不进行YGC，而会直接触发FGC，FULL GC会对整个堆空间（新生代、老年代）以及方法区/永久代进行垃圾回收。<br><font color=red> <strong>注意：FULL GC 主要可以分为两步，先是对 堆中老年代进行垃圾回收（又称之为Major GC），然后再对 堆中新生代进行垃圾回收（YGC）。</strong> </font></p></blockquote><table><tbody><tr><td bgcolor="#FF00FF"><font size="4" color="#fffff">扩展：堆的结构图</font></td></tr></tbody></table><div align=center><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTQwNS5wbmc?x-oss-process=image/format,png" alt=""></div></p><p><strong>3、出现内存溢出后，会自动生成快照，然后分析堆内存快照：</strong></p><p>①、使用XFTP等工具将服务器中的快照文件导出，堆内存快照文件是以<font color="red"> hprof </font>为后缀的文件；导出快照文件后，可以通过JDK自带的<font color="red">  jvisualvm.exe  </font>分析工具打开进行分析。</p><blockquote><p>jvisualvm.exe 是在哪里呢？（以 windows 系统为例）<br>它是在<font color="red">JDK的安装目录中的bin目录下的</font>。</p></blockquote><p>如图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTExMTM1NC5wbmc?x-oss-process=image/format,png" alt=""><br>②、使用 jvisualvm.exe 导入快照文件，如图：<br>（1）、<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTE0NDMwMi5wbmc?x-oss-process=image/format,png" alt=""><br>（2）、<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTE0NDMxNi5wbmc?x-oss-process=image/format,png" alt=""><br>（3）、<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUxNTE0NDMzNS5wbmc?x-oss-process=image/format,png" alt="">     </p><blockquote><p>通过分析堆内存快照得到的结论：<br>通过第（3）张图，可以发现堆内存中有一个实例对象的占比为 99.9%，可以确定是由于这个实例对象大量创建导致堆内存的溢出；<br>说到这，可以回过头去看下我们自己编写的可以触发堆内存溢出的小程序，发现正是由于在 <font color="red"> while(true) </font>死循环 中无线创建 OutOfMemory对象，导致堆内存空间被耗尽。</p></blockquote><blockquote><p><b><font color="blue"> 结语：</font></b><br>通过上面的实战小例子，我们可以大体了解到在出现堆内存溢出时的排查步骤，但是在实际的场景中，这种情况可能会更加的复杂多变；<br>比如说，上面的那个小例子在出现的堆内存溢出时自动生成的堆内存快照文件大小就达到了100多m，如果在实际的场景中，这个可能是非常巨大的，这时可能就会发生快照分析工具无法导入堆内存快照。所以说，我们需要在平时通过不断的学习，才能在未来出现问题时，能尽快定位问题并解决问题；程序员不光是能编写好代码，还需要有解决问题的能力。</p></blockquote><br><table><tr><td bgcolor=#FF00FF><font size = 4px>谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 实战问题排查 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Java实现简单的监控系统</title>
      <link href="/2020/05/05/Java_impl_monitor_system/"/>
      <url>/2020/05/05/Java_impl_monitor_system/</url>
      
        <content type="html"><![CDATA[<p><br><table><tbody><tr><td bgcolor="#FF00FF"><font size="5" color="#fffff">本文只是简单介绍了下监控系统实现的思路，具体还需根据自己需求实现。</font></td></tr></tbody></table><br></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>目前存在一个后台服务系统，此时需要配套一个监控系统，对这个后台服务系统进行监控。下面会涉及到两个系统，后台服务系统（这是已经存在的系统），监控系统（此次需要进行开发的系统）。<font color=red>注意：后面统一将后台服务系统称作服务系统</font>。</p></blockquote><h2 id="具体需求："><a href="#具体需求：" class="headerlink" title="具体需求："></a>具体需求：</h2><p>1、监控服务系统的运行状态，服务系统是否存活，采用模拟数据进行访问接口，如果已down则需要发送告警邮件；</p><p>2、监控服务系统的所有接口是否正常运行，采用模拟数据进行访问接口，如果有问题需要发送告警邮件，邮件内容是模拟访问接口返回的响应；（注：后台服务系统中自定义了相关响应状态码和对应的响应描述）</p><p>3、监控部署了服务系统的服务器的磁盘、CPU、内存的使用情况，会提前设置好使用阀值，如果超过阀值，则要发送告警邮件；</p><p>4、数据采集功能：采集每日服务系统的总访问量、日最大并发量，记录入库，后期做图表展示；</p><p>5、除了上面几个需求外，监控系统还需要具备一些配置页面，用来配置一些监控系统使用的参数：<br>   ①、添加报警邮件配置参数页面，用于配置报警邮件的发送人、收件人等参数；<br>   ②、添加服务器使用阀值的配置参数页面，页面中可以设置服务器（部署后台服务系统的服务器）的磁盘、CPU、内存使用阀值，超过 阀值时需要进行报警；<br>   ③、添加服务器配置页面，这些服务器就是部署了服务系统的机器，它们的ip地址及端口号参数；</p>   <br><blockquote><p>注意：知道了大概的需求后，还要结合服务系统的实际部署方案进行构思具体的开发；<br>   前提：服务系统的部署是以集群（集群：就是将后台服务系统部署在多态服务器中，然后使用Nginx或F5进行请求的转发和负载均衡）的形式进行部署的。</p></blockquote><h2 id="开发构思："><a href="#开发构思：" class="headerlink" title="开发构思："></a>开发构思：</h2><table><tbody><tr><td bgcolor="#03FEED"><font size="5" color="#fffff">定时任务、报警邮件发送所使用工具：</font></td></tr></tbody></table>1、监控系统首先需要实时监控的，所以说会需要定时任务，定时任务使用Quartz来实现。<p>2、发送告警邮件可以使用Hutool这个工具包中的邮件工具类来实现，非常简单方便。</p><table><tbody><tr><td bgcolor="#03FEED"><font size="5" color="#fffff">在服务系统中添加一个filter请求过滤器，这个过滤器主要作用：</font></td></tr></tbody></table>3、服务系统改造：<br>   ①、统计服务系统日总访问量，将每日的日总访问量数据放到redis中，redis存储的key为：当前服务器ip地址+当前日期；每当来一个 请求，就将redis中存储的数据加一；<p>   ②、统计实时的日最大并发访问量也是在该过滤器中，并且将最大并发访问量也是存在redis中，key为：当前服务器ip地址+ “max” + 当前日期；服务系统每来一个请求，就将redis中存储的数据加一，请求处理完成就将redis中存储的数据再减一；</p><table><tbody><tr><td bgcolor="#03FEED"><font size="5" color="#fffff">监控系统中的定时任务：</font></td></tr></tbody></table><p>4、监控系统中的定时任务：<br>   ①、<a href="https://blog.csdn.net/feichitianxia/article/details/104056510" target="_blank" rel="noopener">获取服务器的cpu、内存、磁盘使用情况可以使用shell脚本获取</a>，然后Java操作shell脚本执行并获取到当前服务器的磁盘、CPU、内存的使用率，然后与配置页面中提前配置的使用阀值进行比较，大于阀值的话就需要发送报警邮件。（定时任务，每隔30分钟执行一次）</p><p>   ②、使用定时任务监控后台服务系统是否存活，以及监控所有接口是否正常，根据响应状态码判断出现问题进行报警邮件发送。（定时任务，每隔5分钟执行一次）</p><p>   ③、使用定时任务统计每日最大并发访问量，因为服务系统过滤器中已经统计了服务系统集群中每个节点实时的日最大访问量并存在了redis中，而此时需要一个定时任务将集群的总日最大访问量进行汇总，并存入redis中，此时key为：”max”+当前日期，后面定时任务在每次执行时，都需要先将集群的总日最大并发访问量进行汇总后，与上次 定时任务的统计的日最大并发访问量进行对比，如果比上次统计的大，则将redis中存储的集群总日最大并发访问量更新为当前的；这时操作redis需要至少两步，先读取，然后判断大小，如果大还会去更新，<font color=red>为了保证操作的原子性，需要使用Lua脚本</font>；（定时任务，每隔5秒执行一次，即使这样的话，统计的最大访问量也可能不是准确的，但是也可作为参考）</p><p><font color=red>   <strong>Lua脚本伪代码：</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* lua 脚本：</span></span><br><span class="line"><span class="comment"> * 1、判断key是否存在，key不存在，则新增key-value，value默认为0；</span></span><br><span class="line"><span class="comment"> * 2、如果key存在，则取出value，然后与输入参数进行比较，输入参数大的话就将key的value值更新为输入参数值，否则不进行任何操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String luaScript = <span class="string">"local flag = redis.call('exists',KEYS[1])\n"</span></span><br><span class="line">        + <span class="string">"if (flag == 0) then\n"</span></span><br><span class="line">        +     <span class="string">"redis.call('set', KEYS[1], 1)\n"</span></span><br><span class="line">        + <span class="string">"else \n"</span></span><br><span class="line">        +     <span class="string">"if tonumber(redis.call('get', KEYS[1])) &lt; tonumber(ARGV[1]) then\n"</span></span><br><span class="line">        +         <span class="string">"redis.call('set', KEYS[1], ARGV[1])\n"</span></span><br><span class="line">        +     <span class="string">"end\n"</span></span><br><span class="line">        + <span class="string">"end"</span>;</span><br></pre></td></tr></table></figure><p>   ④、使用定时任务将每台服务器在redis中对应的每日总访问量取出汇总，存入数据库中，以及日最大并发访问量入库。（定时任务，每天的凌晨一分时执行，是统计前一天的总访问量）</p><h2 id="开发构思解析："><a href="#开发构思解析：" class="headerlink" title="开发构思解析："></a>开发构思解析：</h2><p>1、为什么使用redis存放总访问量以及最大访问量呢？因为服务系统是以集群的形式部署的，所以需要统计集群中所有节点的访问量，将其存入redis这种第三方的地方是比较方便的，注意，存在redis中的这些访问量数据需要设置过期时间的，否则redis中数据会导致越来越多，占用内存；</p><p>2、由于使用到了shell脚本获取服务器的磁盘、CPU、内存的使用率，那么集群中的每台服务器都需要存放、运行提前写好的shell脚本，那么也是需要在集群中每台服务器中也要部署    监控系统的；监控系统在部署了集群后，为了保证同一时刻只有一台监控系统运行着定时任务，所以在每个定时任务运行前先设置分布式锁，使用redis设置，设置分布式锁失败的话，就说明集群中有监控系统在执行了，防止定时任务重复执行以及重复数据统计。</p><p>3、在监控系统中配置页面配置的各种参数，是存入在数据库中，集群中所以监控系统连接同一个数据库，当在系统启动时使用监听器从数据库中加载进来的；那么当如果在运行阶段更新了配置参数怎么办呢，因为监控系统是部署的集群，怎么提醒集群中的监控系统去数据库中重新加载新配置数据呢？还是使用redis，key随便，value为时间戳，当集群中的所有监控系统在初始加载配置参数时，会在各自本地设置一个时间戳，redis中也设置了相同的时间戳，当在配置页面修改配置参数时，需要更新时间戳，那么监控系统在使用配置参数时，会对比一个redis中存储的时间戳和本地的时间戳是否一致，不一致说明配置参数更新了，需要到数据库重新加载读取参数。</p><h2 id="开发中遇到的问题："><a href="#开发中遇到的问题：" class="headerlink" title="开发中遇到的问题："></a>开发中遇到的问题：</h2><p>1、<a href="https://blog.csdn.net/feichitianxia/article/details/104071943" target="_blank" rel="noopener">使用Hutool这个工具包中的邮件工具类发送报警邮件出现了一个小问题</a>，邮件配置参数重新去数据库中读取加载了，但是这个工具类使用到的参数还是原来的旧参数，这里是由于工具类中的默认使用的是全局session，所以导致新配置参数不生效；</p><p>2、在多台服务器进行部署服务系统时，监控系统也跟随进行部署多台，那么在数据采集的定时任务由于设置了redis分布式锁，所以不会导致定时任务重复进行采集；但是由于多台服务器的系统时间不一致导致了在每台服务器上部署的监控系统的定时任务会重复执行，就会导致数据库中日最大并发访问量、日总访问量的重复数据产生。即使使用了分布式锁也没有用了。所以在定时任务统计数据入库操作前需要加上校验，校验是否已经存在了这条数据即可。</p><br><table><tbody><tr><td bgcolor="#FF00FF"><font size="5" color="#fffff">谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工作所遇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊Java中的锁，这也是面试时不可避免的 &quot; 锁 &quot; 事！</title>
      <link href="/2020/05/03/chat_java_lock_things/"/>
      <url>/2020/05/03/chat_java_lock_things/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。</p></blockquote><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDUwMzE2MjEwNS5wbmc?x-oss-process=image/format,png" alt=""></p><table><tbody><tr><td bgcolor="#FFA500"><font size="5" color="#fffff">这些只是简单的概念，具体可以根据源码学习！</font></td></tr></tbody></table><br><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect" target="_blank" rel="noopener"> 美团技术团队 ：【基本功】不可不说的Java“锁”事 </a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典面试题（一）、静态代码块、静态属性、构造方法的执行顺序</title>
      <link href="/2020/04/16/written_test_topic_static_construction_run_squence/"/>
      <url>/2020/04/16/written_test_topic_static_construction_run_squence/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>在面试时，下面这道题应该经常遇到；那大家看看这道题中运行Test4中main方法后，控制台的输出内容的顺序是什么样的呀？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3 static start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3 gouzao start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Test4的静态属性类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test5 static start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test5 gouazao start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> <span class="keyword">extends</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Test5 t5 = <span class="keyword">new</span> Test5();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test4 static start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">"test4 gouzao start;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test4 t4 = <span class="keyword">new</span> Test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那我们运行上面子类Test4中的main方法，看看输出内容的顺序是怎样的？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main方法运行结果</span></span><br><span class="line"></span><br><span class="line">test3 <span class="keyword">static</span> start;</span><br><span class="line">test5 <span class="keyword">static</span> start;</span><br><span class="line">test5 gouazao start;</span><br><span class="line">test4 <span class="keyword">static</span> start;</span><br><span class="line">test3 gouzao start;</span><br><span class="line">test4 gouzao start;</span><br></pre></td></tr></table></figure><blockquote><p>大家得出的输出结果与上面的结果一样吗；不一样的话，也别桑心呀，我来带大家去一步步的解析这道题，让大家在面试的时候不在这道题上跌倒。</p></blockquote><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><table><tr><td bgcolor=##03FEED><font size = 3px>首先，大家需要知道几个知识点：</font></td></tr></table><font size = 2px>1、static 代码块的执行、static 属性的初始化都是在类加载的时候进行的；<br><br><p>2、<font size = 2px>在 new 对象时，需要先进行类加载，如果当前类有父类的话，先进行父类的类加载，再进行当前类的类加载。</font></p><p>３、<font size = 2px>类中的静态代码框的执行、静态属性初始化的执行是根据在类中书写的顺序来的；例如：<strong>Test4中的 t5 静态属性就是比静态代码框先执行的。</strong>  </font></p><p>４、<font size = 2px>在 new 对象时，在类加载完后，就该执行构造方法了，如果当前类有父类的话，就需要先执行父类的构造方法。在这里，你需要知道一个在构造方法中使用到 <strong>super();</strong> 方法，它就是进行父类构造方法的调用执行的，但是在无参构造方法中无需自己手动显示调用，JVM会在编译时将其加入进去；</font></p><br><table><tr><td bgcolor=##03FEED><font size = 3px>根据上面的知识点，解析上面的面试题</font></td></tr></table><font size = 2px>1、在 Test4 中执行 main 方法时，首先需要进行 Test4 的类加载；<br><br>2、但是由于 Test4 有父类 Test3 ，所以先进行 Test3 的类加载；<br><br>3、在执行 Test3 的类加载时，会执行静态代码框，输出 <b><font color=red>①" test3 static start; "</font></b><br><br>4、进行完父类的类加载后，执行自己 Test4 的类加载，在进行类加载时，首先执行静态属性 t5 的初始化；<br><br>5、进行 t5 初始化时，是进行的 new 对象，所以需要进行 Test5 的类加载，在进行类加载时，执行静态代码框，输出 <b><font color=red>②" test5 static start; "；</font></b><br><br>6、进行完 Test5 的类加载后，就是执行 Test5 的构造方法来完成 t5 静态属性的初始化，输出 <b><font color=red>③" test5 gouazao start; " ；</font></b><br><br>7、t5 静态属性初始化完成后，需要执行静态代码框，输出 <b><font color=red>④"test4 static start;" ；</font></b><br><br>8、此时 Test4 的类加载完成，此时需要执行构造方法创建对象，但是在执行 Test4 的构造方法时，内部会被JVM内置  super();，它会先去调用父类的构造方法执行，所以会现输出<b><font color=red> ⑤" test3 gouzao start; " </font></b>；最后才输出<b><font color=red> ⑥" test4 gouzao start; "</font></b>；</font><br><br><table><tr><td bgcolor=#FF00FF><font size = 3px>谢谢大家阅读，鉴于本人水平有限，如有问题敬请提出。</font></td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用滑动窗口算法查找字符串中不包含重复字符的最长子串</title>
      <link href="/2020/03/26/find_max_children_string/"/>
      <url>/2020/03/26/find_max_children_string/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>使用滑动窗口算法查找字符串中不包含重复字符的最长子串。</p></blockquote><h2 id="代码奉上："><a href="#代码奉上：" class="headerlink" title="代码奉上："></a>代码奉上：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个测试用的字符串</span></span><br><span class="line">String str = <span class="string">"asdfgrsefkkclgtdxdwee"</span>;</span><br><span class="line"> </span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n = str.length();</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (!set.contains(str.charAt(j))) &#123;</span><br><span class="line"><span class="keyword">char</span> ss = str.charAt(j++);</span><br><span class="line">set.add(ss);</span><br><span class="line">sb.append(ss);</span><br><span class="line">max = max &gt; j - i ? max : j - i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">map.put(sb.length(), sb.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(sb.length(), sb.toString());</span><br><span class="line">set.remove(str.charAt(i++));</span><br><span class="line">sb.delete(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"最大子串的长度："</span> + max);</span><br><span class="line">System.out.println(<span class="string">"最大子串："</span> + map.get(max));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java实现LRU缓存算法</title>
      <link href="/2020/03/20/Java_impl_LRU/"/>
      <url>/2020/03/20/Java_impl_LRU/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>什么是LRU算法：LRU是Least Recently Used的缩写，即最近最久未使用，是一种操作系统中常用的页面置换算法。</p></blockquote><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>知道了什么是LRU后，我们再来聊下它的使用场景；在工作中，对于Redis我们一定是比较熟悉的，它是一个内存数据库；因为它是内存数据库，并且内存的空间是有限的，如果Redis中数据量很大的话，内存就可能被占满，但是此时如果还有数据存入Redis的话，那该怎么办呢？这就是由Redis的的内存淘汰策略所决定的。</p><p>LRU最近最久未使用算法就是Redis的内存淘汰策略之一。 </p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前缓存的容量为2</span></span><br><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><h2 id="设计LRU算法的数据结构："><a href="#设计LRU算法的数据结构：" class="headerlink" title="设计LRU算法的数据结构："></a>设计LRU算法的数据结构：</h2><p>1、要求：<br>①、首先支持查询数据get和写入数据put；<br>②、满足时间复杂度为O(1)；</p><p>2、思路：<br>由题目中要求的O(1)时间复杂度想到缓存可以想到用一个map来存储key、value结点，最近最久未使用到的（缓存数据）放到最后，最新访问的（缓存数据）放到最前面，可以考虑用双向链表来实现，这样，这个map的key对应的是缓存的Key, value对应的是双向链表的一个节点，即链表的节点同时存在map的value中。</p><p>这样，当新插入一个节点时，它应该在这个双向链表的头结点处，同时把这个节点的key和这个节点put到map中保留下来。当LRU缓存链表容量达到最大又要插入新节点时，把链表的尾节点删除掉，同时在map中移除该节点对应的key。</p><p><strong>双向链表中节点的数据结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String key;</span><br><span class="line">Object value;</span><br><span class="line"><span class="comment">// 头指针</span></span><br><span class="line">DoubleLinkedListNode pre;</span><br><span class="line"><span class="comment">// 尾指针</span></span><br><span class="line">DoubleLinkedListNode next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedListNode</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由此可以抽象出LRU缓存算法的数据结构：双向链表+HashMap。</strong></p><p>数据结构逻辑图如下所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDMyMDEzNTkwNi5wbmc?x-oss-process=image/format,png" alt=""></p><h2 id="代码奉上："><a href="#代码奉上：" class="headerlink" title="代码奉上："></a>代码奉上：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, DoubleLinkedListNode&gt; map = <span class="keyword">new</span> HashMap&lt;String, DoubleLinkedListNode&gt;();</span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> DoubleLinkedListNode head;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">private</span> DoubleLinkedListNode tail;</span><br><span class="line"><span class="comment">// 双向链表的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">// 双向链表中节点的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 将节点设置为头结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(DoubleLinkedListNode node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 节点的尾指针执行头结点</span></span><br><span class="line">node.next = head;</span><br><span class="line"><span class="comment">// 节点的头指针置为空</span></span><br><span class="line">node.pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将头结点的头指针执行节点</span></span><br><span class="line">head.pre = node;</span><br><span class="line">&#125;</span><br><span class="line">head = node;</span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果双向链表中还没有节点时，头结点和尾节点都是当前节点</span></span><br><span class="line">tail = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:将双向链表中的节点移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DoubleLinkedListNode node)</span> </span>&#123;</span><br><span class="line">DoubleLinkedListNode cur = node;</span><br><span class="line">DoubleLinkedListNode pre = cur.pre;</span><br><span class="line">DoubleLinkedListNode post = cur.next;</span><br><span class="line"><span class="comment">// 如果当前节点没有头指针的话，说明它是链表的头结点</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">pre.next = post;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head = post;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点没有尾指针的话，说明当前节点是尾节点</span></span><br><span class="line"><span class="keyword">if</span> (post != <span class="keyword">null</span>) &#123;</span><br><span class="line">post.pre = pre;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tail = pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:从缓存Cache中get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用hashmap进行查询，时间复杂度为O(1)，如果进行链表查询，需要遍历链表，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">DoubleLinkedListNode node = map.get(key);</span><br><span class="line"><span class="comment">// 将查询出的节点从链表中移除</span></span><br><span class="line">removeNode(node);</span><br><span class="line"><span class="comment">// 将查询出的节点设置为头结点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存中没有要查询的内容</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:将key-value存储set到缓存Cache中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">DoubleLinkedListNode node = map.get(key);</span><br><span class="line">node.value = value;</span><br><span class="line">removeNode(node);</span><br><span class="line">setHead(node);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果缓存中没有词key-value</span></span><br><span class="line"><span class="comment">// 创建一个新的节点</span></span><br><span class="line">DoubleLinkedListNode newNode = <span class="keyword">new</span> DoubleLinkedListNode(key, value);</span><br><span class="line"><span class="comment">// 如果链表中的节点数小于链表的初始容量（还不需要进行数据置换）则直接将新节点设置为头结点</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">setHead(newNode);</span><br><span class="line"><span class="comment">// 将新节点放入hashmap中，用于提高查找速度</span></span><br><span class="line">map.put(key, newNode);</span><br><span class="line">size++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓存(双向链表)满了需要将"最近醉酒未使用"的节点(尾节点)删除，腾出新空间存放新节点</span></span><br><span class="line"><span class="comment">// 首先将map中的尾节点删除</span></span><br><span class="line">map.remove(tail.key);</span><br><span class="line"><span class="comment">// 移除尾节点并重新置顶尾节点的头指针指向的节点为新尾节点</span></span><br><span class="line">removeNode(tail);</span><br><span class="line"><span class="comment">// 将新节点设置为头节点</span></span><br><span class="line">setHead(newNode);</span><br><span class="line"><span class="comment">// 将新节点放入到map中</span></span><br><span class="line">map.put(key, newNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020年3月20日 下午1:39:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"双向链表的容量为6"</span>);</span><br><span class="line">LRUCache lc = <span class="keyword">new</span> LRUCache(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向缓存中插入set数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">lc.set(<span class="string">"test"</span> + i, <span class="string">"test"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 遍历缓存中的数据，从左到右，数据越不经常使用</span></span><br><span class="line">System.out.println(<span class="string">"第一次遍历双向链表：(从头结点遍历到尾节点)"</span>);</span><br><span class="line">DoubleLinkedListNode node = lc.head;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(node.key + <span class="string">"  "</span>);</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用get查询缓存中数据</span></span><br><span class="line">lc.get(<span class="string">"test2"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再次遍历缓存中的数据，从左到右，数据越不经常使用,并且此次发现刚刚操作的数据节点位于链表的头结点了。</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"get查询 test2节点后 ，第二次遍历双向链表："</span>);</span><br><span class="line">DoubleLinkedListNode node1 = lc.head;</span><br><span class="line"><span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(node1.key + <span class="string">"  "</span>);</span><br><span class="line">node1 = node1.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再次向缓存中插入数据，发现缓存链表已经满了，需要将尾节点移除</span></span><br><span class="line">lc.set(<span class="string">"sucess"</span>, <span class="string">"sucess"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 再次遍历缓存中的数据，从左到右，数据越不经常使用,并且此次发现刚刚set操作时由于链表满了， 就将尾节点test0</span></span><br><span class="line"><span class="comment"> * 移除了，并且将新节点置为链表的头结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"put插入sucess节点后，第三次遍历双向链表："</span>);</span><br><span class="line">DoubleLinkedListNode node2 = lc.head;</span><br><span class="line"><span class="keyword">while</span> (node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(node2.key + <span class="string">"  "</span>);</span><br><span class="line">node2 = node2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果展示："><a href="#运行结果展示：" class="headerlink" title="运行结果展示："></a>运行结果展示：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">双向链表容量为<span class="number">6</span></span><br><span class="line">第一次遍历双向链表：(从头结点遍历到尾节点)</span><br><span class="line">test5  test4  test3  test2  test1  test0  </span><br><span class="line"></span><br><span class="line">get查询 test2节点后 ，第二次遍历双向链表：</span><br><span class="line">test2  test5  test4  test3  test1  test0  </span><br><span class="line"></span><br><span class="line">put插入sucess节点后，第三次遍历双向链表：</span><br><span class="line">sucess  test2  test5  test4  test3  test1</span><br></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、<a href="https://blog.csdn.net/m0_37907797/article/details/104277209" target="_blank" rel="noopener">记一次阿里面试，我挂在了 最熟悉不过的LRU 缓存算法设计上。。。。。</a><br>2、 <a href="https://blog.csdn.net/qq_37372007/article/details/88418224" target="_blank" rel="noopener">【LeetCode】146. LRU缓存机制</a><br>3、<a href="https://www.cnblogs.com/springfor/p/3869393.html" target="_blank" rel="noopener">LRU Cache leetcode java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java使用Trie树算法实现敏感词替过滤、根据关键词自动联想</title>
      <link href="/2020/03/18/Java_Impl_Trie/"/>
      <url>/2020/03/18/Java_Impl_Trie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Trie树也称为 <span style="color:red"> 字典树、单词查找树 </span>，最大的特点就是共享字符串的公共前缀来达到节省空间的目的了。<br>然后可以根据它的公共前缀的特性来实现敏感词过滤、自动联想等功能。</p></blockquote><h2 id="抽象出trie树的数据结构："><a href="#抽象出trie树的数据结构：" class="headerlink" title="抽象出trie树的数据结构："></a>抽象出trie树的数据结构：</h2><p>1、首先来看下trie树的结构图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDMxODE0NTkwOS5wbmc?x-oss-process=image/format,png" alt=""><br><strong>从上图可以归纳出Trie树的基本性质：</strong><br>①根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>②从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>③每个节点的所有子节点包含的字符互不相同。<br>④从第一字符开始有连续重复的字符只占用一个节点，比如上面的to，和ten，中重复的单词t只占用了一个节点</p><p><strong>从上面归纳出的基本性质可以抽象出节点的class属性：</strong><br>1、是否为叶子节点的标志位  <span style="color:blue"><strong>isWord</strong></span> ；<br>2、既能存储此节点的值也能存储其所有的子节点的 <span style="color:blue"><strong>children</strong></span> 数据结构HashMap；</p><h2 id="代码奉上："><a href="#代码奉上：" class="headerlink" title="代码奉上："></a>代码奉上：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lyl.trie;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: trie树的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="comment">// 节点是否为叶子节点的标志；true：叶子节点，false：非叶子节点（用于子节点的节点）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line"><span class="comment">// 当前节点拥有的孩子节点，使用hashmap进行存储，在查找子节点时的时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Character, Node&gt; children;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.isWord = isWord;</span><br><span class="line"><span class="keyword">this</span>.children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// trie树的根节点</span></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">// trie树中拥有多少分枝（多少个敏感词）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 返回trie树中分枝树（敏感词树）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 向trie树中添加分枝/敏感词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> *            添加的敏感词</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBranchesInTrie</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置当前节点为根节点</span></span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words) &#123;</span><br><span class="line"><span class="comment">// 判断当前节点的子节点中是否存在字符c</span></span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line"><span class="comment">// 如果不存在则将其添加进行子节点中</span></span><br><span class="line">cur.children.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前节点进行变换，变换为新插入到节点 c</span></span><br><span class="line">cur = cur.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分枝添加完成后，将分枝中的最后一个节点设置为叶子节点</span></span><br><span class="line"><span class="keyword">if</span> (!cur.isWord) &#123;</span><br><span class="line">cur.isWord = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 分枝数（敏感词数）加1</span></span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 判断trie树中是否存在某分枝/敏感词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果存在并且遍历到trie树中某个分支最后一个节点了，那此节点就是叶子节点，直接返回true</span></span><br><span class="line"><span class="keyword">return</span> cur.isWord;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 如果一段话中有trie树中存储的敏感词则需将其进行替换为 **; 例如：尼玛的，替换为 **的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> *            一段话，如果有敏感词需要被替换的词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sensitiveWordReplace</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"敏感词替换前："</span> + word);</span><br><span class="line"> </span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"><span class="comment">// 需要被替换的敏感词</span></span><br><span class="line">StringBuilder oldTemp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 需要替换成的星号</span></span><br><span class="line">StringBuilder starTemp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line"><span class="comment">// 如果当前节点的孩子节点中没有此单词则直接跳过此循环，进入下次循环</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cur.isWord) &#123;</span><br><span class="line"><span class="comment">// 拼接上word和trie树都有的字符</span></span><br><span class="line">oldTemp.append(c);</span><br><span class="line">starTemp.append(<span class="string">"*"</span>);</span><br><span class="line">cur = cur.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.isWord) &#123;</span><br><span class="line"><span class="comment">// 进行敏感词替换</span></span><br><span class="line">word = word.replaceAll(oldTemp.toString(), starTemp.toString());</span><br><span class="line"><span class="comment">// 清空StringBuilder中内容</span></span><br><span class="line">oldTemp.delete(<span class="number">0</span>, oldTemp.length());</span><br><span class="line">starTemp.delete(<span class="number">0</span>, starTemp.length());</span><br><span class="line"><span class="comment">// 查找一个敏感词并替换后，需要重新从根节点进行遍历，所以当前节点指向root</span></span><br><span class="line">cur = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"敏感词替换后："</span> + word);</span><br><span class="line"><span class="keyword">return</span> word;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 存放trie树中查询到的联想词</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 利用trie的公共前缀特性，可以实现关键词自动联想</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prefixMatching</span><span class="params">(String word, Node root)</span> </span>&#123;</span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">str.append(word);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cur.children.containsKey(words[i])) &#123;</span><br><span class="line">System.out.println(<span class="string">"无关联词！"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.children.get(words[i]);</span><br><span class="line">&#125;</span><br><span class="line">dfs(str, cur);</span><br><span class="line">System.out.println(<span class="string">"[ "</span> + word + <span class="string">" ]在trie树中的联想词："</span> + Arrays.toString(list.toArray()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 节点遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment"> *            需要查找的词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> *            开始遍历的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(StringBuilder word, Node root)</span> </span>&#123;</span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">if</span> (cur.isWord) &#123;</span><br><span class="line">list.add(word.toString());</span><br><span class="line"><span class="keyword">if</span> (cur.children.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Character s : cur.children.keySet()) &#123;</span><br><span class="line">word.append(s);</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line">dfs(word, cur.children.get(s));</span><br><span class="line">word.delete(word.length() - <span class="number">1</span>, word.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line"><span class="comment">// 插入敏感词</span></span><br><span class="line">t.addBranchesInTrie(<span class="string">"麻痹"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"尼玛的"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"狗日的"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 插入联想词</span></span><br><span class="line">t.addBranchesInTrie(<span class="string">"联想云科技"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"联盟"</span>);</span><br><span class="line">t.addBranchesInTrie(<span class="string">"联和利泰扩招了"</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"trie树中分枝的个数："</span> + t.size);</span><br><span class="line"> </span><br><span class="line">String word = <span class="string">"尼玛的"</span>;</span><br><span class="line">System.out.println(<span class="string">"Trie树中是否存在[ "</span> + word + <span class="string">" ]敏感词: "</span> + t.contains(word));</span><br><span class="line"><span class="comment">// 敏感词替换测试</span></span><br><span class="line">t.sensitiveWordReplace(<span class="string">"衮，尼玛的傻子，你麻痹的，你各狗日的，早晚揍死你。"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// trie树实现联想测试</span></span><br><span class="line">t.prefixMatching(<span class="string">"联"</span>, t.root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码运行输出："><a href="#代码运行输出：" class="headerlink" title="代码运行输出："></a>代码运行输出：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trie树中分枝的个数：<span class="number">6</span></span><br><span class="line">Trie树中是否存在[ 尼玛的 ]敏感词: <span class="keyword">true</span></span><br><span class="line">敏感词替换前：衮，尼玛的傻子，你麻痹的，你各狗日的，早晚揍死你。</span><br><span class="line">敏感词替换后：衮，***傻子，你**的，你各***，早晚揍死你。</span><br><span class="line">[ 联 ]在trie树中的联想词：[联想云科技, 联和利泰扩招了, 联盟]</span><br></pre></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、<a href="https://blog.csdn.net/m0_37907797/article/details/103272967" target="_blank" rel="noopener">【图解算法面试】记一次面试：说说游戏中的敏感词过滤是如何实现的？</a><br>2、 <a href="https://blog.csdn.net/u013309870/article/details/71081393?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">前缀树（Trie）原理及Java实现</a><br>3、<a href="https://blog.csdn.net/Nino_sama/article/details/100981325?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Trie树（字典树/前缀树）Java实现</a><br>4、<a href="https://www.wmathor.com/index.php/archives/1185/" target="_blank" rel="noopener">Trie 树实现搜索引擎自动联想 </a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构+算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中的位运算符</title>
      <link href="/2020/02/29/Java_run_operator/"/>
      <url>/2020/02/29/Java_run_operator/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>位运算符比一般的算术运算符速度要</strong>快，而且可以实现一些算术运算符不能实现的功能。如果要开发高效率程序，位运算符是必不可少的 。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位运算符用来对二进制位进行操作，包括：按位与（&amp;）、按位或（|）、按位异或（^）、按位取反（~）、按位左移（&lt;&lt;）、按位右移（&gt;&gt;）、按位无符号右移（&gt;&gt;&gt;）。</p></blockquote><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>例子：指定 A = 60（0011 1100）; B = 13 （0000 1101）</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9JbWFnZS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy93ZWlodW8ucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy95aWh1by5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9mYW4ucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy96dW95aS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy95b3V5aS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9ub3lvdXlpLnBuZw?x-oss-process=image/format,png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大工具让你飞起，就问你它香不香！嘿嘿......</title>
      <link href="/2020/02/28/six_tool_fly/"/>
      <url>/2020/02/28/six_tool_fly/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>十大工具让你工作更加顺畅，生活更加甜蜜，快来瞅瞅并收藏哟！括弧 <strong>(收藏不看系列不也挺香的呀，嘿嘿…..)</strong> </p></blockquote><h2 id="工具展示："><a href="#工具展示：" class="headerlink" title="工具展示："></a>工具展示：</h2><h4 id="1-印象笔记"><a href="#1-印象笔记" class="headerlink" title="1. 印象笔记"></a>1. 印象笔记</h4><p>这是一个记笔记的软件，肥肠好用，我从大学开始一直用到现在，现在推荐给大家；</p><p>注册的免费用户可以同时在两个终端进行登录，本人平时在笔记本、手机同时登录着，如果需要查询笔记看，可以拿起手机来就查询，你说它香不香，嘿嘿。</p><p>如果大家感觉同时两个终端登录还不够的话，例如有的大佬，需要在自己的台式机、mac本、平板、手机都同时登陆的话，那咱花钱升级账户，咱不差钱呢，哼！<br>[更多功能大家自己去探索哟。] &nbsp;&nbsp; 网址：<a href="https://www.yinxiang.com/" target="_blank" rel="noopener">https://www.yinxiang.com/</a></p><p><strong>上图：</strong> PC端软件长这个样，手机端大家可以自己去下载瞅瞅，反正挺香的！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy95aW54aWFuZy5wbmc?x-oss-process=image/format,png" alt=""></p><h4 id="2-Beyond-Compare-4"><a href="#2-Beyond-Compare-4" class="headerlink" title="2. Beyond Compare 4"></a>2. Beyond Compare 4</h4><p>Beyond Compare 4 主要用途是对比两个文件夹或者文件，并将差异以颜色标示。<br>其实它也可以用来进行比较两个版本不同的项目（指同一个项目，但是版本号不同）， 将其快速进行代码同步。</p><p>注：此软件有30天试用期的，大家可以在网上找些破解教程，很多的。</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="http://www.scootersoftware.com/download.php" target="_blank" rel="noopener">http://www.scootersoftware.com/download.php</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9iZXlvbmQucG5n?x-oss-process=image/format,png" alt=""></p><h4 id="3-JMeter"><a href="#3-JMeter" class="headerlink" title="3. JMeter"></a>3. JMeter</h4><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具，用于对软件做压力测试。</p><p>JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能；完全的可移植性和100% 纯java。</p><p>之前自己写了个监控系统，需要监控服务器的使用情况，后面就是使用的 JMeter 压服务器来得到监控数据的。括弧（后面会写一篇文章：java实现监控系统，敬请期待哟！）</p><p>最后再附上一份JMeter 的详细使用教程：<a href="https://www.cnblogs.com/testwjr/p/9156705.html" target="_blank" rel="noopener">https://www.cnblogs.com/testwjr/p/9156705.html</a>  </p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9qbWV0ZXIucG5n?x-oss-process=image/format,png" alt=""></p><h4 id="4-阿里巴巴矢量图标"><a href="#4-阿里巴巴矢量图标" class="headerlink" title="4. 阿里巴巴矢量图标"></a>4. 阿里巴巴矢量图标</h4><p>Iconfont-阿里巴巴矢量图标：国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能。</p><p>这对于前端攻城狮来说是非常棒的，并且对于我们全栈攻城狮也是不可或缺的。因为开发软件时经常会需要一些图标，如果自己制作的话耗时耗力；在知道了矢量图标库后，自己就可以直接去里面找符合自己心意的，省时省力，你说它不香吗，嘿嘿。</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9pY29uMS5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9pY29uMi5wbmc?x-oss-process=image/format,png" alt=""></p><p>例如，本人的<a href="https://leishen6.github.io/">个人博客</a>中有很多图标就是从其中找的，我感觉挺香的呀！嘿嘿……  </p><p><strong>来来上图：</strong> (图中画圈的都是啊，大家看看香不香。)：</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200606143018.png" alt=""></p><h4 id="5-Markdown编辑器：Typora"><a href="#5-Markdown编辑器：Typora" class="headerlink" title="5. Markdown编辑器：Typora"></a>5. Markdown编辑器：Typora</h4><p>上面刚刚提到了搭建的个人博客，那我们就趁热打铁来聊聊写博客所用的工具。博客搭建好了，那么就需要写博文了呀，并且现在国内知名的博客网站（例如：<a href="https://segmentfault.com/u/muzilei_5e72d30d2c9fb" target="_blank" rel="noopener">思否</a>、<a href="https://juejin.im/user/5c67b8046fb9a049a7125a58/posts" target="_blank" rel="noopener">掘金</a>、<a href="https://blog.csdn.net/feichitianxia" target="_blank" rel="noopener">CSDN</a>  等) 都支持Markdown语法的，那使用其写完博客后就可以一键发布到多个网站中了，这是不是就属于<strong>《 一次编写，到处发布》</strong> ，嘿嘿 . . . . . . . ，想想就高兴 ！</p><p>接下来就主要介绍下 <strong>Typora</strong> 编辑器工具啦！ 它真的是太太太太太 . . . . . 好用了，不仅上手容易，而且支持的功能很多，下面简单介绍它提供的功能：</p><p>①、支持 Markdown语法 </p><p>②、支持导出各种格式的文件（例如：PDF、HTML、Word文档、图片等）</p><p>③、原生支持数学公式编辑</p><p>④、等等 . . . . . . . . . . . （更多功能等待大家去挖掘咯！）</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><p><strong>上图：</strong> Windows 版是这样婶的</p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200606152453.png" alt=""></p><h4 id="6-漂亮的代码模版：Carbon"><a href="#6-漂亮的代码模版：Carbon" class="headerlink" title="6. 漂亮的代码模版：Carbon"></a>6. 漂亮的代码模版：Carbon</h4><p>说到了写博客，那博文中不可避免的就需要展示一些代码，那怎样才能使代码展示起来更加牛X呢，别犹豫，就使用 <strong>Carbon</strong>  ，你绝对不会后悔，使用了Carbon后，你的博文绝对会吸引很多读者，博文浏览量就飕飕的飙起来啦！哈哈，开玩笑呀，虽说实际效果可能没我说的那么神，但是你来试试的话，就会能感受到实际的威能啦。</p><p><strong>注意了：这个是需要导出为图片的。</strong></p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://carbon.now.sh/" target="_blank" rel="noopener">https://carbon.now.sh/</a></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200606151842.png" alt=""></p><p><strong>再来提供一张在博客中使用效果图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200531191044.png" alt=""></p><h4 id="7-表情包在线制作模板大全"><a href="#7-表情包在线制作模板大全" class="headerlink" title="7. 表情包在线制作模板大全"></a>7. 表情包在线制作模板大全</h4><p>表情包，这个东西我想每个人的手机中都存有不收吧，嘿嘿 . . . .   没事时老司机斗斗图，还有在和妹子聊天时，不时的发个表情包活跃下聊天气氛 。这表情包最主要的作用就是简单明了，越看越想乐，活跃气氛之利器呀。</p><p>所以，在写博客时，表情包也不可或缺的，它可以使我们的文章看起来不那么枯燥，提高读者的阅读兴趣；反之，如果全文都是文字，那一看起来就头大了，都没有继续读下去的心情了，那 . . . 不就糟糕了吗。</p><p>平时在写博文时，去哪里找自己想要的表情包呢？ 别着急呀，我们可以去  <a href="https://www.52doutu.cn/maker/1/?order=timedown" target="_blank" rel="noopener">斗图表情包在线制作</a>  ，里面不仅已经存在了大量现成的表情包，也可以自己在线制作所需的表情包。</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://www.52doutu.cn/maker/1/?order=timedown" target="_blank" rel="noopener">https://www.52doutu.cn/maker/1/?order=timedown</a></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200606155023.png" alt=""></p><h4 id="8-比特虫-在线制作ico图标"><a href="#8-比特虫-在线制作ico图标" class="headerlink" title="8. 比特虫 在线制作ico图标"></a>8. 比特虫 在线制作ico图标</h4><p>接下来，再介绍一个肥肠棒的 <strong>在线制作ico图标</strong> 的网站 <strong>“比特虫”</strong>，它可将<strong>png、jpg</strong>等后缀的图片转为<strong>ico</strong>的图标。注意：在进行转化前选好图标的尺寸哟。大家可以去试试，我感觉挺香的，嘿嘿！</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="http://www.bitbug.net/" target="_blank" rel="noopener">http://www.bitbug.net/</a></p><p><strong>上图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9iaXRjaG9uZy5wbmc?x-oss-process=image/format,png" alt=""></p><h4 id="9-processon-在线画图工具"><a href="#9-processon-在线画图工具" class="headerlink" title="9. processon 在线画图工具"></a>9. processon 在线画图工具</h4><p>processon 这个在线画图工具在我上大学时就使用的，我感觉它也是非常棒的，大家先瞅瞅它的官网；</p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9wcm9jZXNzT24ucG5n?x-oss-process=image/format,png" alt=""></p><blockquote><p>在上学时，在<strong>Java实现爬虫</strong>的项目中使用 <strong>processon</strong> 画的流程图等，大家来瞅瞅。</p></blockquote><p><strong>先上第一张图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9jcmF3bGVyX2ltZzEucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>来来第二张图：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9jcmF3bGVyX2ltZzIucG5n?x-oss-process=image/format,png" alt=""></p><blockquote><p>现在写博客后，博文中的一些图大多数也是使用 <strong>processon</strong>  来画的，例如：这篇 <a href="https://segmentfault.com/a/1190000022791475" target="_blank" rel="noopener">单链表反转？面试官你确定要问这个吗？</a>  文章中的图片。</p></blockquote><p><strong>上图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200530184205.png" alt=""></p><h4 id="10-思维导图工具：XMind"><a href="#10-思维导图工具：XMind" class="headerlink" title="10. 思维导图工具：XMind"></a>10. 思维导图工具：XMind</h4><p>思维导图，可以帮助我们更加好的梳理知识，可以通过思维导图快速记忆及回顾知识，让我们的大脑可以如同电脑一样，所有知识入脑即不丢失的呀，嘿嘿 . . . . . . . </p><p>[更多功能大家自己去探索哟。]&nbsp;&nbsp; 网址：<a href="https://www.xmind.cn/" target="_blank" rel="noopener">https://www.xmind.cn/</a></p><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200606161834.png" alt=""></p><blockquote><p>再来一张我自己画的思维导图，嘿嘿嘿  . . . . . . . . . . . . </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leishen6/ImgHosting/MuZiLei_blog_img/20200503162105.png" alt=""></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><blockquote><p>暂时就这些了，如果以后再遇到更好的工具时，会立即分享给大家，使我们大家工作顺畅，生活甜蜜！嘿嘿……..</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么数据脱敏及其实现方式</title>
      <link href="/2020/02/25/data_desensitization/"/>
      <url>/2020/02/25/data_desensitization/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据脱敏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发核心技术-幂等实现方案</title>
      <link href="/2020/02/25/power_etc/"/>
      <url>/2020/02/25/power_etc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>柔性事务与传统事务</title>
      <link href="/2020/02/25/flexible_transaction/"/>
      <url>/2020/02/25/flexible_transaction/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表策略，如何分库，如何分表？</title>
      <link href="/2020/02/24/DB_Sharding_Strategy/"/>
      <url>/2020/02/24/DB_Sharding_Strategy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全网最全redis学习脑图</title>
      <link href="/2020/02/21/redis_learn_mind_map/"/>
      <url>/2020/02/21/redis_learn_mind_map/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>本文为<span style="color:#2BFA05;"><strong>转载文章</strong></span>，转自一个<a href="https://blog.csdn.net/qq_35190492/category_9606008.html" target="_blank" rel="noopener">大佬</a>。分享一个全网最全的redis学习脑图。</p></blockquote><h2 id="redis脑图："><a href="#redis脑图：" class="headerlink" title="redis脑图："></a>redis脑图：</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy9SZWRpcyVFNSVBRCVBNiVFNCVCOSVBMCVFOCU4NCU5MSVFNSU5QiVCRS5qcGc?x-oss-process=image/format,png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 非关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实现使用 _DESede_ 对称加密的 加解密工具类</title>
      <link href="/2020/02/18/java_imp_DESede_%20util/"/>
      <url>/2020/02/18/java_imp_DESede_%20util/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Java实现 “DESede” 对称加密；</p></blockquote><h2 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h2><blockquote><p>在代码运行前，需要提前将一个依赖导入到项目中 pom.xml 中，使用这个依赖中的base64进行编解码；</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- base64编码使用 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESedeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密钥算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"DESede"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加密/解密算法 / 工作模式 / 填充方式</span></span><br><span class="line"><span class="comment"> * Java 6支持PKCS5Padding填充方式</span></span><br><span class="line"><span class="comment"> * Bouncy Castle支持PKCS7Padding填充方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"DESede/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生成密钥, 返回168位的密钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//实例化密钥生成器</span></span><br><span class="line">KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line"><span class="comment">//DESede 要求密钥长度为 112位或168位</span></span><br><span class="line">kg.init(<span class="number">168</span>);</span><br><span class="line"><span class="comment">//生成密钥</span></span><br><span class="line">SecretKey secretKey = kg.generateKey();</span><br><span class="line"><span class="comment">//获得密钥的字符串形式</span></span><br><span class="line"><span class="keyword">return</span> Base64.encodeBase64String(secretKey.getEncoded());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: DES进行加密</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source 待加密的原字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  加密时使用的 密钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   返回经过base64编码的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String source, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] sourceBytes = source.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE,<span class="keyword">new</span> SecretKeySpec(keyBytes, KEY_ALGORITHM));</span><br><span class="line">    <span class="keyword">byte</span>[] decrypted = cipher.doFinal(sourceBytes);</span><br><span class="line">    <span class="keyword">return</span> Base64.encodeBase64String(decrypted);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:  DES解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr  DES加密后的再经过base64编码的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  加密使用的密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  返回 utf-8 编码的明文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptStr, String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] sourceBytes = Base64.decodeBase64(encryptStr);</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE,<span class="keyword">new</span> SecretKeySpec(keyBytes, KEY_ALGORITHM));</span><br><span class="line">    <span class="keyword">byte</span>[] decoded = cipher.doFinal(sourceBytes);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(decoded, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 生成秘钥</span></span><br><span class="line">        String key = generateKey();</span><br><span class="line">        System.out.println(<span class="string">"秘钥："</span>+key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        String encryptStr = encrypt(<span class="string">"hello"</span>, key);</span><br><span class="line">        System.out.println(<span class="string">"密文："</span>+ encryptStr);</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        String resource = decrypt(encryptStr, key);</span><br><span class="line">        System.out.println(<span class="string">"明文："</span>+ resource);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"校验："</span>+ <span class="string">"hello"</span>.equals(resource));</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 amcharts.js 实现立体柱状图</title>
      <link href="/2020/02/15/imp_histogram_byAmcharts/"/>
      <url>/2020/02/15/imp_histogram_byAmcharts/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p> 本文章将使用<span style="color:red;"> <strong>amcharts.js</strong> </span>实现立体柱状图，以下代码中的js库是直接引入网络中的js文件，所以代码拷贝下来是可以直接运行的。</p></blockquote><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDE5MTIxODE0MTYyNjUzOC5wbmc?x-oss-process=image/format,png" alt=""></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;立体柱状图&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 立体柱状图 --&gt;</span><br><span class="line">&lt;script src="https://www.amcharts.com/lib/3/amcharts.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src="https://www.amcharts.com/lib/3/serial.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div id=<span class="string">"car3"</span> style=<span class="string">"text-align:center;width:440px;height:180px;"</span>&gt;</span><br><span class="line"> &lt;script type=<span class="string">"text/javascript"</span>&gt;      </span><br><span class="line"> <span class="keyword">var</span> chartData = [&#123; country: <span class="string">"订单未确定"</span>, visits: <span class="number">50</span> , <span class="string">"color"</span>: <span class="string">"#067ADD"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单已确定"</span>, visits: <span class="number">166</span> , <span class="string">"color"</span>: <span class="string">"#FA0606"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单已处理"</span>, visits: <span class="number">26</span>  , <span class="string">"color"</span>: <span class="string">"#14EF06"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单完成"</span>, visits: <span class="number">80</span> , <span class="string">"color"</span>: <span class="string">"#F802BC"</span>&#125;,</span><br><span class="line"> &#123; country: <span class="string">"订单已发货"</span>, visits: <span class="number">56</span> , <span class="string">"color"</span>: <span class="string">"#0FFBF9"</span>&#125;,</span><br><span class="line">   ];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> chart = <span class="keyword">new</span> AmCharts.AmSerialChart();</span><br><span class="line"> chart.dataProvider = chartData;</span><br><span class="line"> chart.categoryField = <span class="string">"country"</span>;<span class="comment">//获取"chartData"中的文本内容</span></span><br><span class="line"> chart.color = <span class="string">"#4C4CFD"</span>; <span class="comment">//标题颜色（x、y轴的字体颜色）</span></span><br><span class="line"> chart.startDuration = <span class="number">2</span>;  <span class="comment">//动画特效 延迟时间 秒  </span></span><br><span class="line"> chart.columnWidth = <span class="number">0.4</span>; <span class="comment">//柱状图宽度</span></span><br><span class="line"> chart.depth3D = <span class="number">8</span>;<span class="comment">//3D厚度</span></span><br><span class="line"> chart.angle = <span class="number">30</span>;</span><br><span class="line"> chart.depth3D = <span class="number">15</span>;<span class="comment">//控制列的深度和角度</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> categoryAxis = chart.categoryAxis;</span><br><span class="line"> categoryAxis.gridColor = <span class="string">"#067ADD"</span>; <span class="comment">//网格线颜色</span></span><br><span class="line"> categoryAxis.axisColor = <span class="string">"#067ADD"</span>;  <span class="comment">//横坐标轴颜色</span></span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> valueAxis = <span class="keyword">new</span> AmCharts.ValueAxis();  <span class="comment">//纵坐标轴</span></span><br><span class="line"> valueAxis.axisColor = <span class="string">"#067ADD"</span>;  <span class="comment">//纵坐标轴轴线的颜色</span></span><br><span class="line"> chart.addValueAxis(valueAxis);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> graph = <span class="keyword">new</span> AmCharts.AmGraph();</span><br><span class="line"> graph.valueField = <span class="string">"visits"</span> ; <span class="comment">//获取"chartData"中的数量</span></span><br><span class="line"> graph.colorField = <span class="string">"color"</span>;<span class="comment">//获取"chartData"中的配置颜色</span></span><br><span class="line"> <span class="comment">//graph.lineColor = "#067ADD";//柱状图的颜色,这里是全部设置成为统一 #067ADD 颜色</span></span><br><span class="line"> <span class="comment">//graph.topRadius = 1;   //设置为椭圆柱体,默认是长方形柱体</span></span><br><span class="line"> graph.lineAlpha = <span class="number">0.1</span>;</span><br><span class="line"> graph.fillAlphas = <span class="number">0.85</span>;</span><br><span class="line"> graph.type = <span class="string">"column"</span>;<span class="comment">//柱形，也可是设置为 line 折线图等</span></span><br><span class="line"> chart.addGraph(graph);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> graph.fillAlphas = <span class="number">1</span>;<span class="comment">//填充柱形图的颜色</span></span><br><span class="line"> graph.balloonText = <span class="string">"&lt;b&gt;[[category]]: [[value]] 单&lt;/b&gt;"</span>;<span class="comment">//鼠标悬浮时展示数据的格式</span></span><br><span class="line"> </span><br><span class="line"> chart.write(<span class="string">'car3'</span>); <span class="comment">//将js写入到div容器中</span></span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试手写HashMap，手撕HashMap</title>
      <link href="/2020/02/12/interview_Implement_HashMap/"/>
      <url>/2020/02/12/interview_Implement_HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>现在面试时，面试官经常会问到HashMap，简单点就会问下HashMap的一些关键知识点，困难些的可能会当场让你手写一个HashMap，考察下你对HashMap底层原理的了解深度；所以，今天特别手写了一个简单的HashMap，只实现了<span style="color:red;"> put、get、containsKey、keySet </span>方法的 HashMap，来帮助我们理解HashMap的底层设计原理。<br>本文参考：<a href="https://blog.csdn.net/huangshulang1234/article/details/79713303" target="_blank" rel="noopener">手写实现一个HashMap</a></p></blockquote><h2 id="手撕HashMap："><a href="#手撕HashMap：" class="headerlink" title="手撕HashMap："></a>手撕HashMap：</h2><h4 id="1-首先定义接口："><a href="#1-首先定义接口：" class="headerlink" title="1. 首先定义接口："></a>1. 首先定义接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Title</span>: MyMap </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义map接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午3:56:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 插入键值对方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午3:59:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k,V v)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:根据key获取value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午3:59:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 判断key键是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k  key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午4:07:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取map集合中所有的key，并放入set集合中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午4:24:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt;  <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------内部接口 Entry（存放key-value）---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Enter </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 定义内部接口 Entry，存放键值对的Entery接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午4:00:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取key方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午4:02:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:获取value方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午4:02:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-接口实现类："><a href="#2-接口实现类：" class="headerlink" title="2. 接口实现类："></a>2. 接口实现类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Title</span>: MyHashMap </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:   MyMap接口的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午4:04:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>,<span class="string">"rawtypes"</span>,<span class="string">"hiding"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry数组的默认初始化长度为16；通过位移运算向左移动四位，得到二进制码 "00010000",转换为十进制是16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子默认为0.75f；负载因子是用来标志当使用容量占总容量的75%时，就需要扩充容量了，</span></span><br><span class="line"><span class="comment"> * 扩充Entry数组的长度为原来的两倍，并且重新对所存储的key-value键值对进行散列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可设置的初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultInitSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可设置的负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> defaultLoadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前已存入的元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> entryUseSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放key-value键值对对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K, V&gt;[] table = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造，数组初始大小为16，负载因子大小为0.75f</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY,DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造，自己设置数组初始大小和负载因子大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultInitialCapacity  数组初始大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultLoadFactor2    负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> defaultInitialCapacity, <span class="keyword">float</span> defaultLoadFactor2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断初始容量参数是否合法</span></span><br><span class="line"><span class="keyword">if</span> (defaultInitialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//抛出非法参数异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的初始容量参数是非法的  ："</span>+defaultInitialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断负载因子参数是否合法，Float.isNaN()方法是判断数据是否符合 0.0f/0.0f</span></span><br><span class="line"><span class="keyword">if</span> (defaultLoadFactor2 &lt; <span class="number">0</span> || Float.isNaN(defaultLoadFactor2)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的负载因子参数是非法的  ："</span>+defaultLoadFactor2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.defaultInitSize = defaultInitialCapacity;</span><br><span class="line"><span class="keyword">this</span>.defaultLoadFactor = defaultLoadFactor2;</span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line">table = <span class="keyword">new</span> Entry[<span class="keyword">this</span>.defaultInitSize];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 集合中的put方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如是更新则返回key的旧value值，如是插入新的key-value则返回null</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午6:29:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">V oldValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//是否需要扩容？</span></span><br><span class="line"><span class="comment">//扩容完毕后一定会需要重新进行散列</span></span><br><span class="line"><span class="keyword">if</span> (entryUseSize &gt;= defaultInitSize * defaultLoadFactor) &#123;</span><br><span class="line"><span class="comment">//扩容并重新散列,扩容为原来的两倍</span></span><br><span class="line">resize(<span class="number">2</span> * defaultInitSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据key获取的HASH值、数组长度减1，两者做'与'运算，计算出数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> index = hash(k) &amp; (defaultInitSize -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//如果数组中此下标位置没有元素的话，就直接放到此位置上</span></span><br><span class="line"><span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">table[index] = <span class="keyword">new</span> Entry(k, v, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//总存入元素数量+1</span></span><br><span class="line">++entryUseSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//遍历数组下边的链表</span></span><br><span class="line">Entry&lt;K,V&gt; entry = table[index];</span><br><span class="line">Entry&lt;K,V&gt; e = entry;</span><br><span class="line"><span class="keyword">while</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (k == e.getKey() || k.equals(e.getKey())) &#123;</span><br><span class="line">oldValue = e.getValue();</span><br><span class="line"><span class="comment">//key已存在，直接更新value</span></span><br><span class="line">e.value = v;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组此下标位置上链表的下个元素</span></span><br><span class="line">e = e.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK1.7中的链表头插法，直接占据数组下标位置</span></span><br><span class="line">    table[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(k, v, entry);</span><br><span class="line">    <span class="comment">//总存入元素数量+1</span></span><br><span class="line">    ++entryUseSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据key获取value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午6:34:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过hash函数和数组元素容量做  【与】运算得到数组下标</span></span><br><span class="line"><span class="keyword">int</span> index = hash(k) &amp; (defaultInitSize -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//获取到数组下标位置元素</span></span><br><span class="line">Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">Entry&lt;K, V&gt; e = entry;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k.equals(e.getKey())) &#123;</span><br><span class="line"><span class="keyword">return</span> e.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组下标位置对应链表中的下一个元素</span></span><br><span class="line">e = e.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:扩容并重新将元素进行散列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i  扩容后的大小</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午5:06:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">Entry&lt;K,V&gt;[] newTable = <span class="keyword">new</span> Entry[size];</span><br><span class="line"><span class="comment">//改变数组的初始大小</span></span><br><span class="line">defaultInitSize = size ;</span><br><span class="line"><span class="comment">//将已存放键值对数量置为0</span></span><br><span class="line">entryUseSize = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//将已存的元算根据最新的数组的大小进行散列</span></span><br><span class="line">rehash(newTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 重新进行散列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newTable</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午5:10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(Entry&lt;K, V&gt;[] newTable)</span></span>&#123;</span><br><span class="line">List&lt;Entry&lt;K, V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; entry : table)&#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//将原来数组中的元素放到list集合中</span></span><br><span class="line">entryList.add(entry);</span><br><span class="line"><span class="comment">//如果此数组下标的位置存在链表的话，需要遍历下列表，将列表中的键值对数据取出来放到集合中</span></span><br><span class="line">entry = entry.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将旧的数组引用覆盖，让引用指向堆中新开辟的数组</span></span><br><span class="line"><span class="keyword">if</span> (newTable.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所谓重新的散列hash，就是将元素重新放入到扩容后的集合中</span></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; entry : entryList)&#123;</span><br><span class="line"><span class="comment">//重新put</span></span><br><span class="line">put(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据key获取hashcod码值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月13日 下午5:52:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 判断是否存在此key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k  key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午4:52:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = hash(k) &amp; (defaultInitSize -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//获取到数组下标位置元素</span></span><br><span class="line">Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">Entry&lt;K, V&gt; e = entry;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k.equals(e.getKey())) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组下标位置对应链表中的下一个元素</span></span><br><span class="line">e = e.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flag; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取map集合所有的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午5:52:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entryUseSize == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;K&gt; entrySet = <span class="keyword">new</span> HashSet&lt;K&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; entry : table)&#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//将原来数组中的元素的key放到set集合中</span></span><br><span class="line">entrySet.add(entry.getKey());</span><br><span class="line"><span class="comment">//如果此数组下标的位置存在链表的话，需要遍历下列表，将列表中元素的key取出来放到集合中</span></span><br><span class="line">entry = entry.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------内部类 Entry（存放key-value）----------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Entry </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 实现了key-value简直对接口的java类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午6:12:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对对象的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> K key;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对对象的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span>  V value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对对象指向下一个键值对对象的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-测试方法："><a href="#3-测试方法：" class="headerlink" title="3. 测试方法："></a>3. 测试方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: TestMyMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年7月13日 下午6:49:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:单元测试</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@date</span>: 2019年7月23日 下午7:07:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyMap&lt;String, String&gt; map = <span class="keyword">new</span> MyHashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//插入键值对</span></span><br><span class="line">map.put(<span class="string">"key"</span> + i, <span class="string">"value"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"key"</span> + i + <span class="string">",value is："</span> + map.get(<span class="string">"key"</span> + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取value</span></span><br><span class="line">System.out.println(<span class="string">"\n"</span>+<span class="string">"此key：key88 的value是   "</span>+map.get(<span class="string">"key88"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断key是否存在</span></span><br><span class="line">    System.out.println(map.containsKey(<span class="string">"key885"</span>)+<span class="string">"   此key：key885 不存在！"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取map集合中所有的key</span></span><br><span class="line">    System.out.println(Arrays.toString(map.keySet().toArray()));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    MyMap&lt;String, String&gt; mapOther = <span class="keyword">new</span> MyHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; keySet = mapOther.keySet();</span><br><span class="line">    <span class="comment">//获取map集合中所有的key</span></span><br><span class="line">    System.out.println((keySet == <span class="keyword">null</span>)?<span class="keyword">null</span>:Arrays.toString(mapOther.keySet().toArray()));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo+Zookeeper vs Spring Cloud 之间的比较</title>
      <link href="/2020/02/12/Dubbo_Zookeeper%20_vs_SpringCloud/"/>
      <url>/2020/02/12/Dubbo_Zookeeper%20_vs_SpringCloud/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>目前学习了下Dubbo 和  Spring Cloud，并且在简单学习后，总结了下这两者之间简单的区别；如果以后有需要搭建分布式系统的需求，可以根据这两者之间的区别，再根据当前公司的业务等情况选择最为合适的来搭建自己的分布式系统。</p></blockquote><h2 id="Dubbo-Zookeeper-vs-Spring-Cloud："><a href="#Dubbo-Zookeeper-vs-Spring-Cloud：" class="headerlink" title="Dubbo+Zookeeper   vs   Spring Cloud："></a>Dubbo+Zookeeper   <span style="color:red;"><strong>vs</strong></span>   Spring Cloud：</h2><table><thead><tr><th>框架比较的方面</th><th>Dubbo+Zookeeper</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>性能方面</td><td>Dubbo是阿里巴巴开源的顶级项目，以前是用于阿里巴巴的分布式服务治理框架,其性能毋庸置疑一定是很强的，它适合一些比较大的公司用的分布式服务治理框架。（注：2017年之前阿里巴巴没有对其进行更新维护，但是2017年Dubbo项目官网宣布重新对其进行更新维护，并且在2018年Dubbo项目正式进入了Apache孵化器）</td><td>Spring Cloud是最近才兴起的一个分布式服务框架，现在它的社区十分的火爆，代码的更新迭代十分的快；它一般适合于中小型企业，并且性能比Dubbo低一些；</td></tr><tr><td>具有的特点</td><td>Dubbo有良好的连通性、健壮性、伸缩性、升级性。结合Dubbo可以相对于单体系统提升系统整体的扩展性。<br> Dubbo提供了多种协议给用户选择， 如dubbo、hessian、rmi 。 并可为每个服务指定不同的传输协议，粒度可以细化到方法， 不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议。</td><td>Spring Cloud来源于Spring，质量、稳定性、持续性都可以得到保证。<br>Spirng Cloud天然支持Spring Boot，更加便于业务落地。<br>Spring Cloud是Java领域最适合做微服务的框架。<br>相比于其它框架,Spring Cloud对微服务周边环境的支持力度最大。</td></tr><tr><td>方便性</td><td>Dubbo使用起来不太方便，由于许多组件其本身不支持，所以我们在搭建架构环境时，需要集成一些其他的开源组件，集成时会遇到种种的困难，并且在以后的项目维护和升级也不方便。<br>Dubbo服务调用的方式是RPC，服务提供方与调用方接口依赖方式太强：我们需要将调用的抽象接口依赖到消费者项目中才能调用服务，这会导致在以后的开发、测试、版本管理上很麻烦。</td><td>pringCloud自身的组件可以搭建成一个完整的微服务架构，并且搭建起来稍微简单一些；<br>SpringCloud调用的方式是REST，REST接口相比RPC更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然REST接口也有缺点，很容易导致定义文档与实际实现不一致导致服务集成时的问题。</td></tr><tr><td>灵活性</td><td>由于dubbo许多组件都是集成的第三方，所以dubbo组件之间的自由度很高，dubbo更加的灵活。</td><td>SpringCloud自身支持了组件，各个组件之间的关联关系已经配置好了，所以它的灵活度不是很好，如果想要用第三方组件代替其中的一个组件的话会有一些困难。</td></tr><tr><td>服务注册中心</td><td>Zookeeper保证<span style="color:red;">C(一致性)P(分区容错性)</span>。<br>当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。</td><td>Eureka保证<span style="color:red;">A(可用性)P(分区容错性)</span>。<br>Eureka各个节点都是平等的，几个节点挂掉不会影响正常工作。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)</td></tr><tr><td>代码开发角度</td><td>Dubbo常与Spring、zookeeper结合，而且实现只是通过xml来配置服务地址、名称、端口，代码的侵入性是很小的，可以说几乎没有代码入侵。</td><td>Spring Cloud，由于它的实现需要类注解等，所以多少具有一定代码侵入。</td></tr></tbody></table><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总的来说这两个搭建分布式系统的框架各有各的好处，在选择时要根据自己的需求等情况综合做选择；<br> 但是Eureka作为单纯的服务注册中心来说感觉要比Zookeeper更加<span style="color:red;">“<strong>专业</strong>”</span>，因为注册服务更重要的是高可用性，可以接受短期内达不到一致性的状况。</p><p> <span style="color:red;"><strong>注：</strong></span>可能此文章中表格内容看起来不太舒服，你还可以参考我在CSDN中的<a href="https://blog.csdn.net/feichitianxia/article/details/92682828" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 集群分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> Zookeeper </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现 “ 将数字金额转为大写中文金额 ”</title>
      <link href="/2020/02/09/Java_imp_chinease_monery/"/>
      <url>/2020/02/09/Java_imp_chinease_monery/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>输入数字金额参数，运行程序得到其对应的大写中文金额；例如：输入— 12.56，输出— 12.56:壹拾贰元伍角陆分；重点来了：<span style="color:red;"><strong><em>本人亲测有效</em></strong></span>。</p></blockquote><h2 id="奉上代码："><a href="#奉上代码：" class="headerlink" title="奉上代码："></a>奉上代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Title</span>: ConvertUpMoney </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  将数字金额转为大写汉字金额</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年6月18日 下午10:52:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertUpMoney</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大写数字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NUMBERS = &#123;<span class="string">"零"</span>,<span class="string">"壹"</span>,<span class="string">"贰"</span>,<span class="string">"叁"</span>,<span class="string">"肆"</span>,<span class="string">"伍"</span>,<span class="string">"陆"</span>,<span class="string">"柒"</span>,<span class="string">"捌"</span>,<span class="string">"玖"</span>&#125;;</span><br><span class="line"><span class="comment">// 整数部分的单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] IUNIT = &#123;<span class="string">"元"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>,<span class="string">"万"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>,<span class="string">"亿"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>,<span class="string">"万"</span>,<span class="string">"拾"</span>,<span class="string">"佰"</span>,<span class="string">"仟"</span>&#125;;</span><br><span class="line">    <span class="comment">//小数部分的单位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DUNIT = &#123;<span class="string">"角"</span>,<span class="string">"分"</span>,<span class="string">"厘"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转成中文的大写金额</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toChinese</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断输入的金额字符串是否符合要求</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(str) || !str.matches(<span class="string">"(-)?[\\d]*(.)?[\\d]*"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"抱歉，请输入数字！"</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"0"</span>.equals(str) || <span class="string">"0.00"</span>.equals(str) || <span class="string">"0.0"</span>.equals(str)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"零元"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在负号"-"</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(str.startsWith(<span class="string">"-"</span>))&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">str = str.replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str = str.replaceAll(<span class="string">","</span>, <span class="string">""</span>);<span class="comment">//去掉","</span></span><br><span class="line">String integerStr;<span class="comment">//整数部分数字</span></span><br><span class="line">String decimalStr;<span class="comment">//小数部分数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化：分离整数部分和小数部分</span></span><br><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">"."</span>)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">integerStr = str.substring(<span class="number">0</span>,str.indexOf(<span class="string">"."</span>));</span><br><span class="line">decimalStr = str.substring(str.indexOf(<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.indexOf(<span class="string">"."</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">integerStr = <span class="string">""</span>;</span><br><span class="line">decimalStr = str.substring(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">integerStr = str;</span><br><span class="line">decimalStr = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//beyond超出计算能力，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(integerStr.length()&gt;IUNIT.length) &#123;</span><br><span class="line">System.out.println(str+<span class="string">"：超出计算能力"</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] integers = toIntArray(integerStr);<span class="comment">//整数部分数字</span></span><br><span class="line"><span class="comment">//判断整数部分是否存在输入012的情况</span></span><br><span class="line"><span class="keyword">if</span> (integers.length&gt;<span class="number">1</span> &amp;&amp; integers[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"抱歉，请输入数字！"</span>);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">str = <span class="string">"-"</span>+str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> isWan = isWan5(integerStr);<span class="comment">//设置万单位</span></span><br><span class="line"><span class="keyword">int</span>[] decimals = toIntArray(decimalStr);<span class="comment">//小数部分数字</span></span><br><span class="line">String result = getChineseInteger(integers,isWan)+getChineseDecimal(decimals);<span class="comment">//返回最终的大写金额</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"负"</span>+result;<span class="comment">//如果是负数，加上"负"</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串转为int数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] toIntArray(String number) &#123;</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[number.length()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;number.length();i++) &#123;</span><br><span class="line">array[i] = Integer.parseInt(number.substring(i,i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将整数部分转为大写的金额</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChineseInteger</span><span class="params">(<span class="keyword">int</span>[] integers,<span class="keyword">boolean</span> isWan)</span> </span>&#123;</span><br><span class="line">StringBuffer chineseInteger = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">int</span> length = integers.length;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">1</span> &amp;&amp; integers[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(integers[i] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>((length - i) == <span class="number">13</span>)<span class="comment">//万（亿）</span></span><br><span class="line">key = IUNIT[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((length - i) == <span class="number">9</span>) &#123;<span class="comment">//亿</span></span><br><span class="line">key = IUNIT[<span class="number">8</span>];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((length - i) == <span class="number">5</span> &amp;&amp; isWan) &#123;<span class="comment">//万</span></span><br><span class="line">key = IUNIT[<span class="number">4</span>];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((length - i) == <span class="number">1</span>) &#123;<span class="comment">//元</span></span><br><span class="line">key = IUNIT[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((length - i)&gt;<span class="number">1</span> &amp;&amp; integers[i+<span class="number">1</span>]!=<span class="number">0</span>) &#123;</span><br><span class="line">key += NUMBERS[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chineseInteger.append(integers[i]==<span class="number">0</span>?key:(NUMBERS[integers[i]]+IUNIT[length - i -<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chineseInteger.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将小数部分转为大写的金额</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getChineseDecimal</span><span class="params">(<span class="keyword">int</span>[] decimals)</span> </span>&#123;</span><br><span class="line">StringBuffer chineseDecimal = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;decimals.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">chineseDecimal.append(decimals[i]==<span class="number">0</span>?<span class="string">""</span>:(NUMBERS[decimals[i]]+DUNIT[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chineseDecimal.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前整数部分是否已经是达到【万】</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isWan5</span><span class="params">(String integerStr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = integerStr.length();</span><br><span class="line"><span class="keyword">if</span>(length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">String subInteger = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(length &gt; <span class="number">8</span>) &#123;</span><br><span class="line">subInteger = integerStr.substring(length- <span class="number">8</span>,length -<span class="number">4</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">subInteger = integerStr.substring(<span class="number">0</span>,length - <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(subInteger) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String number = <span class="string">"12.56"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"1234567890563886.123"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"1600"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"156,0"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"-156,0"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"0.12"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"0.0"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"01.12"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"0125"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"-0125"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">number = <span class="string">"sdw5655"</span>;</span><br><span class="line">System.out.println(number+<span class="string">": "</span>+ConvertUpMoney.toChinese(number));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">null</span>+<span class="string">": "</span>+ConvertUpMoney.toChinese(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加个彩蛋："><a href="#加个彩蛋：" class="headerlink" title="加个彩蛋："></a>加个彩蛋：</h2><blockquote><p>本人在平时的学习中，还看到了一个十分有用的工具包，这个工具包中含有一个类型转换的方法，可以实现“ 金额的大小写 ”，但是这个工具包也有一些局限，“ 转换为大写只能精确到分（<span style="color:red;"><strong>小数点儿后两位</strong></span>），之后的数字会被忽略 ”；这个工具包叫“ <span style="color:red;"><strong>Hutool</strong></span> ”，学习地址：<a href="https://www.hutool.cn/docs/#/core/类型转换/类型转换工具类-Convert" target="_blank" rel="noopener">https://www.hutool.cn/docs/#/core/类型转换/类型转换工具类-Convert</a>  。</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><blockquote><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒汉式单例模式为什么要进行二次判空</title>
      <link href="/2020/02/08/singleton_twoIfNull_reason/"/>
      <url>/2020/02/08/singleton_twoIfNull_reason/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>在本文中会使用代码进行展示懒汉单例模式为什么需要进行二次判空；代码中使用到 <span style="color:red;"><strong>CountDownLatch 倒计时器</strong></span>，不清楚CountDownLatch 使用的请参考此文<a href="https://www.jianshu.com/p/f17692e9114f" target="_blank" rel="noopener">“倒计时器：CountDownLatch”</a> 。</p></blockquote><h2 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h2><h5 id="1、懒汉式单例模式类"><a href="#1、懒汉式单例模式类" class="headerlink" title="1、懒汉式单例模式类"></a>1、懒汉式单例模式类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用volatile禁止指令重排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton sin = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 标识有几个线程获取到了锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">// 标识系统中到底生成了几个实例</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将构造器的修饰符设置为"private"，可以防止在外部进行new实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取实例对象的方法，公共的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一次判空。</span></span><br><span class="line"><span class="keyword">if</span> (sin == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 第二次判空。</span></span><br><span class="line"><span class="keyword">if</span> (sin == <span class="keyword">null</span>) &#123;</span><br><span class="line">sin = <span class="keyword">new</span> Singleton();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sin;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、多线程并发调用单例模式的测试类"><a href="#2、多线程并发调用单例模式的测试类" class="headerlink" title="2、多线程并发调用单例模式的测试类"></a>2、多线程并发调用单例模式的测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个倒计树器,初始倒计数为10</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadTest demo = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//实例对象生成</span></span><br><span class="line">Singleton.getInstance();</span><br><span class="line"><span class="comment">//输出当前线程的名称</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//计数器进行减一</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//创建一个长度为10的定长线程池</span></span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待检查,阻塞main主线程,只有当CountDownLatch倒计数器为0时才会唤醒阻塞的main主线程</span></span><br><span class="line">        latch.await();  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开启的10个线程中几个线程获取到了锁</span></span><br><span class="line">System.out.println(<span class="string">"共有 ( "</span> + Singleton.i + <span class="string">" ) 个线程获取到对象锁"</span>);</span><br><span class="line"><span class="comment">// 最终生成了几个Singleton实例</span></span><br><span class="line">System.out.println(<span class="string">"最终生成了( "</span> + Singleton.j + <span class="string">" )个Singleton实例对象"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行上面的mian方法，会得到以下的一种输出结果-存在多种输出结果"><a href="#运行上面的mian方法，会得到以下的一种输出结果-存在多种输出结果" class="headerlink" title="运行上面的mian方法，会得到以下的一种输出结果(存在多种输出结果)"></a>运行上面的mian方法，会得到以下的一种输出结果(存在多种输出结果)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span></span><br><span class="line">共有 ( <span class="number">2</span> ) 个线程获取到对象锁</span><br><span class="line">最终生成了( <span class="number">1</span> )个Singleton实例对象</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> 从运行结果可以看出，如果不进行第二次判空的话，那么在<span style="color:red;">竟锁池(锁池)</span>中如果还有活跃的线程在等待获取的锁的话，在锁释放后就会再次竞争获取锁，获取的锁的线程进入”就绪状态”，当cpu分配其”时间片”后进行线程的调度，从而线程进入”运行中状态”，并会去执行同步的代码块，如果在没加如二次判空的话，就会导致系统中存在多个实例，而在进行判空后，即使你获取到了锁，但在执行同步代码块时也会直接跳过。</p><p>竟锁池(锁池)的概念：<a href="https://blog.csdn.net/qq_22498277/article/details/82184419" target="_blank" rel="noopener">Java中的锁池和等待池</a></p><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本查询服务器的cpu、内存、磁盘的使用率</title>
      <link href="/2020/02/07/search_cpu_memery_disk_byShell/"/>
      <url>/2020/02/07/search_cpu_memery_disk_byShell/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>使用shell脚本查询服务器的cpu、内存、磁盘的使用率；如果需要对此脚本进行理解的话，请首先熟悉下<a href="https://blog.csdn.net/feichitianxia/article/details/103088793" target="_blank" rel="noopener">linux的基本命令和管道符的知识</a>。</p></blockquote><h2 id="脚本献上："><a href="#脚本献上：" class="headerlink" title="脚本献上："></a>脚本献上：</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#计算cpu使用率, -n number：指定在结束前应该产生的最大迭代次数或帧数,一般迭代次数越大，获取到的cpu使用率越准确; 本脚本中是迭代了5次，"-n5" </span></span><br><span class="line">cpu=`top <span class="literal">-b</span> <span class="literal">-n5</span> | fgrep <span class="string">"Cpu(s)"</span> | tail <span class="literal">-1</span> | awk <span class="operator">-F</span><span class="string">'id,'</span> <span class="string">'&#123;split($1, vs, ","); v=vs[length(vs)]; sub(/\s+/, "", v);sub(/\s+/, "", v); printf "%d", 100-v;&#125;'</span>`</span><br><span class="line">echo <span class="variable">$cpu</span><span class="string">'%'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#统计内存使用率</span></span><br><span class="line">mem_used_persent=`free <span class="literal">-m</span> | awk <span class="operator">-F</span> <span class="string">'[ :]+'</span> <span class="string">'NR==2&#123;printf "%d", ($3)/$2*100&#125;'</span>`</span><br><span class="line"><span class="comment"># -e参数是使 "\n"换行符生效进行输出换行的</span></span><br><span class="line">echo <span class="literal">-e</span> <span class="variable">$mem_used_persent</span><span class="string">'%\n'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#统计磁盘使用情况，df -P参数可以防止打印输出的内容换行</span></span><br><span class="line">df <span class="literal">-THP</span> | awk <span class="operator">-F</span> <span class="string">'[ ]+'</span> <span class="string">'NR!=1&#123;print $1","$6&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p>12%<br>37%</p><p>/dev/mapper/vg_minghui-lv_root,25%<br>tmpfs,1%<br>/dev/sda1,10%<br>/dev/sr0,100%</p><p>前两行的内容：12% - cpu的使用率， 37% - 内存的使用率；</p><p>后面四行的内容：每个磁盘分区的使用率，磁盘分区名称和其使用率之间用英文逗号隔开。</p><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><blockquote><p>在脚本编写好，且运行前，可以先使用命令<font color=red>  bash &nbsp;  -n  &nbsp;  *.sh  </font> 判断下脚本是否存在语法错误，如果存在语法错误的话，再使用命令 <font color=red> bash  &nbsp; -x   &nbsp; *.sh  </font> 一步步执行脚本看下到底哪个地方存在语法错误。</p></blockquote><h2 id="❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ"><a href="#❤不要忘记留下你学习的足迹-点赞-收藏-评论-嘿嘿ヾ" class="headerlink" title="❤不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ"></a><span style="color:red;">❤</span>不要忘记留下你学习的足迹 [点赞 + 收藏 + 评论]嘿嘿ヾ</h2><p>一切看文章不点赞都是“耍流氓”，嘿嘿ヾ(◍°∇°◍)ﾉﾞ！开个玩笑，动一动你的小手，点赞就完事了，你每个人出一份力量(点赞 + 评论)就会让更多的学习者加入进来！非常感谢！￣ω￣=</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo测试</title>
      <link href="/2020/01/19/HelloWorld/"/>
      <url>/2020/01/19/HelloWorld/</url>
      
        <content type="html"><![CDATA[<p>测试：Hello ，欢迎来到java的海洋。</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
